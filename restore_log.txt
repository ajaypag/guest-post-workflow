pg_restore: error: could not execute query: ERROR:  type "page_type" already exists
Command was: CREATE TYPE public.page_type AS ENUM (
    'landing_page',
    'blog_post',
    'tool_page',
    'resource_page',
    'case_study',
    'other'
);


pg_restore: error: could not execute query: ERROR:  type "payment_method" already exists
Command was: CREATE TYPE public.payment_method AS ENUM (
    'bank_transfer',
    'credit_card',
    'paypal',
    'check',
    'cash',
    'stripe',
    'other'
);


pg_restore: error: could not execute query: ERROR:  type "payment_status" already exists
Command was: CREATE TYPE public.payment_status AS ENUM (
    'pending',
    'completed',
    'failed',
    'refunded',
    'partial',
    'cancelled'
);


pg_restore: error: could not execute query: ERROR:  type "recreation_status" already exists
Command was: CREATE TYPE public.recreation_status AS ENUM (
    'identified',
    'analyzed',
    'in_progress',
    'completed',
    'published',
    'skipped'
);


pg_restore: error: could not execute query: ERROR:  function "calculate_platform_fee" already exists with same argument types
Command was: CREATE FUNCTION public.calculate_platform_fee(p_publisher_id uuid, p_website_id uuid, p_amount bigint, p_order_type character varying DEFAULT 'standard'::character varying) RETURNS TABLE(platform_fee bigint, commission_percent numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_commission_percent DECIMAL(5,2);
  v_platform_fee BIGINT;
BEGIN
  -- Get applicable commission rate (priority: publisher > website > global)
  SELECT COALESCE(
    -- Publisher-specific rate
    (SELECT base_commission_percent FROM commission_configurations 
     WHERE scope_type = 'publisher' AND scope_id = p_publisher_id 
     AND is_active = true AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
     ORDER BY created_at DESC LIMIT 1),
    -- Website-specific rate  
    (SELECT base_commission_percent FROM commission_configurations 
     WHERE scope_type = 'website' AND scope_id = p_website_id 
     AND is_active = true AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
     ORDER BY created_at DESC LIMIT 1),
    -- Global rate
    (SELECT base_commission_percent FROM commission_configurations 
     WHERE scope_type = 'global' AND scope_id IS NULL 
     AND is_active = true AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
     ORDER BY created_at DESC LIMIT 1),
    -- Fallback default
    30.00
  ) INTO v_commission_percent;
  
  -- Calculate fee
  v_platform_fee := ROUND(p_amount * v_commission_percent / 100);
  
  RETURN QUERY SELECT v_platform_fee, v_commission_percent;
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "create_publisher_earning_on_completion" already exists with same argument types
Command was: CREATE FUNCTION public.create_publisher_earning_on_completion() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_platform_fee_info RECORD;
BEGIN
  -- Only process if status changed to 'completed' and publisher is assigned
  IF NEW.status = 'completed' AND OLD.status != 'completed' AND NEW.publisher_id IS NOT NULL THEN
    
    -- Calculate platform fee
    SELECT * INTO v_platform_fee_info 
    FROM calculate_platform_fee(
      NEW.publisher_id,
      (SELECT website_id FROM publisher_offering_relationships 
       WHERE publisher_id = NEW.publisher_id LIMIT 1),
      NEW.publisher_price,
      'standard'
    );
    
    -- Create earnings record
    INSERT INTO publisher_earnings (
      publisher_id,
      order_line_item_id,
      order_id,
      earning_type,
      amount,
      gross_amount,
      platform_fee_percent,
      platform_fee_amount,
      net_amount,
      status,
      website_id,
      description
    ) VALUES (
      NEW.publisher_id,
      NEW.id,
      NEW.order_id,
      'order_completion',
      NEW.publisher_price,
      NEW.publisher_price,
      v_platform_fee_info.commission_percent,
      v_platform_fee_info.platform_fee,
      NEW.publisher_price - v_platform_fee_info.platform_fee,
      'pending',
      (SELECT website_id FROM publisher_offering_relationships 
       WHERE publisher_id = NEW.publisher_id LIMIT 1),
      'Earnings for completed order'
    );
    
    -- Update publisher status
    NEW.publisher_status := 'completed';
  END IF;
  
  RETURN NEW;
END;
$$;


pg_restore: error: could not execute query: ERROR:  relation "websites" already exists
Command was: CREATE TABLE public.websites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    airtable_id character varying(255),
    domain character varying(255) NOT NULL,
    domain_rating integer,
    total_traffic numeric(12,2),
    guest_post_cost numeric(10,2),
    categories text[],
    type text[],
    status character varying(50) DEFAULT 'Unknown'::character varying,
    has_guest_post boolean DEFAULT false,
    has_link_insert boolean DEFAULT false,
    published_opportunities integer DEFAULT 0,
    overall_quality character varying(255),
    airtable_created_at timestamp without time zone NOT NULL,
    airtable_updated_at timestamp without time zone NOT NULL,
    last_synced_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    website_type text[],
    niche text[],
    publisher_tier character varying(20) DEFAULT 'standard'::character varying,
    preferred_content_types text[],
    editorial_calendar_url text,
    content_guidelines_url text,
    typical_turnaround_days integer,
    accepts_do_follow boolean DEFAULT true,
    requires_author_bio boolean DEFAULT false,
    max_links_per_post integer,
    primary_contact_id uuid,
    publisher_company character varying(255),
    website_language character varying(10) DEFAULT 'en'::character varying,
    target_audience text,
    avg_response_time_hours numeric(10,2),
    success_rate_percentage numeric(5,2),
    last_campaign_date date,
    total_posts_published integer DEFAULT 0,
    internal_quality_score numeric(3,2),
    internal_notes text,
    account_manager_id uuid,
    organization_id uuid,
    normalized_domain character varying(255),
    source character varying(50) DEFAULT 'airtable'::character varying,
    added_by_publisher_id uuid,
    added_by_user_id uuid,
    source_metadata jsonb DEFAULT '{}'::jsonb,
    import_batch_id character varying(100),
    CONSTRAINT check_website_source CHECK (((source)::text = ANY ((ARRAY['airtable'::character varying, 'publisher'::character varying, 'internal'::character varying, 'api'::character varying, 'migration'::character varying, 'manual'::character varying, 'manyreach'::character varying])::text[])))
);


pg_restore: error: could not execute query: ERROR:  function "find_website_by_domain" already exists with same argument types
Command was: CREATE FUNCTION public.find_website_by_domain(input_domain text) RETURNS SETOF public.websites
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM websites 
    WHERE normalized_domain = normalize_domain(input_domain)
    LIMIT 1;  -- Return first match if duplicates exist
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "generate_placeholder_airtable_id" already exists with same argument types
Command was: CREATE FUNCTION public.generate_placeholder_airtable_id(source_type character varying, entity_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
      BEGIN
        RETURN UPPER(source_type || '_' || 
                     TO_CHAR(NOW(), 'YYYYMMDD_HH24MISS') || '_' || 
                     SUBSTRING(entity_id::TEXT, 1, 8));
      END;
      $$;


pg_restore: error: could not execute query: ERROR:  function "get_publisher_pending_earnings" already exists with same argument types
Command was: CREATE FUNCTION public.get_publisher_pending_earnings(p_publisher_id uuid) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN COALESCE(
    (SELECT SUM(net_amount) 
     FROM publisher_earnings 
     WHERE publisher_id = p_publisher_id 
     AND status IN ('pending', 'confirmed')
     AND payment_batch_id IS NULL),
    0
  );
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "log_publisher_status_change" already exists with same argument types
Command was: CREATE FUNCTION public.log_publisher_status_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF OLD.account_status IS DISTINCT FROM NEW.account_status THEN
    INSERT INTO publisher_automation_logs (
      publisher_id,
      action,
      previous_data,
      new_data,
      metadata,
      created_at
    ) VALUES (
      NEW.id,
      'status_change',
      jsonb_build_object('account_status', OLD.account_status),
      jsonb_build_object('account_status', NEW.account_status),
      jsonb_build_object(
        'changed_from', OLD.account_status,
        'changed_to', NEW.account_status,
        'trigger', 'database'
      ),
      NOW()
    );
  END IF;
  RETURN NEW;
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "migrate_website_pricing_to_offerings" already exists with same argument types
Command was: CREATE FUNCTION public.migrate_website_pricing_to_offerings() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  website_record RECORD;
  publisher_record RECORD;
  offering_id UUID;
BEGIN
  -- For each website with a publisher and guest post cost
  FOR website_record IN 
    SELECT w.*, pw.publisher_id 
    FROM websites w
    JOIN publisher_websites pw ON w.id = pw.website_id
    WHERE w.guest_post_cost IS NOT NULL
  LOOP
    -- Create offering if publisher exists
    SELECT * INTO publisher_record FROM publishers WHERE id = website_record.publisher_id;
    
    IF publisher_record.id IS NOT NULL THEN
      -- Create guest post offering
      INSERT INTO publisher_offerings (
        publisher_id,
        offering_type,
        base_price,
        turnaround_days,
        is_active
      ) VALUES (
        publisher_record.id,
        'guest_post',
        website_record.guest_post_cost::INTEGER,
        7, -- default turnaround
        true
      ) RETURNING id INTO offering_id;
      
      -- Create relationship
      INSERT INTO publisher_offering_relationships (
        publisher_id,
        offering_id,
        website_id,
        is_primary,
        is_active
      ) VALUES (
        publisher_record.id,
        offering_id,
        website_record.id,
        true,
        true
      ) ON CONFLICT (publisher_id, website_id) DO NOTHING;
    END IF;
  END LOOP;
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "normalize_domain" already exists with same argument types
Command was: CREATE FUNCTION public.normalize_domain(input_domain text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    normalized TEXT;
BEGIN
    IF input_domain IS NULL OR input_domain = '' THEN
        RETURN NULL;
    END IF;
    
    -- Convert to lowercase
    normalized := LOWER(TRIM(input_domain));
    
    -- Remove protocol
    normalized := REGEXP_REPLACE(normalized, '^https?://', '');
    
    -- Remove www prefix (but keep other subdomains like blog, shop, etc)
    normalized := REGEXP_REPLACE(normalized, '^www\.', '');
    
    -- Remove trailing slash and path
    normalized := REGEXP_REPLACE(normalized, '/.*$', '');
    
    -- Remove port
    normalized := REGEXP_REPLACE(normalized, ':[0-9]+$', '');
    
    -- Remove any trailing dots
    normalized := RTRIM(normalized, '.');
    
    RETURN normalized;
END;
$_$;


pg_restore: error: could not execute query: ERROR:  function "trigger_normalize_domain" already exists with same argument types
Command was: CREATE FUNCTION public.trigger_normalize_domain() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.normalized_domain := normalize_domain(NEW.domain);
    RETURN NEW;
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "update_project_stats" already exists with same argument types
Command was: CREATE FUNCTION public.update_project_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
      BEGIN
        -- Update counts for NEW project
        IF NEW.project_id IS NOT NULL THEN
          UPDATE bulk_analysis_projects SET
            domain_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = NEW.project_id),
            qualified_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = NEW.project_id AND qualification_status IN ('high_quality', 'good_quality', 'marginal_quality')),
            workflow_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = NEW.project_id AND has_workflow = true),
            last_activity_at = NOW()
          WHERE id = NEW.project_id;
        END IF;
        
        -- Also update old project if domain moved
        IF TG_OP = 'UPDATE' AND OLD.project_id IS NOT NULL AND OLD.project_id != NEW.project_id THEN
          UPDATE bulk_analysis_projects SET
            domain_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id),
            qualified_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id AND qualification_status IN ('high_quality', 'good_quality', 'marginal_quality')),
            workflow_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id AND has_workflow = true)
          WHERE id = OLD.project_id;
        END IF;
        
        RETURN NEW;
      END;
      $$;


pg_restore: error: could not execute query: ERROR:  function "update_project_stats_on_delete" already exists with same argument types
Command was: CREATE FUNCTION public.update_project_stats_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
      BEGIN
        IF OLD.project_id IS NOT NULL THEN
          UPDATE bulk_analysis_projects SET
            domain_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id),
            qualified_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id AND qualification_status IN ('high_quality', 'good_quality', 'marginal_quality')),
            workflow_count = (SELECT COUNT(*) FROM bulk_analysis_domains WHERE project_id = OLD.project_id AND has_workflow = true)
          WHERE id = OLD.project_id;
        END IF;
        
        RETURN OLD;
      END;
      $$;


pg_restore: error: could not execute query: ERROR:  function "update_publisher_offerings_updated_at" already exists with same argument types
Command was: CREATE FUNCTION public.update_publisher_offerings_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


pg_restore: error: could not execute query: ERROR:  function "update_updated_at_column" already exists with same argument types
Command was: CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
          BEGIN
              NEW.updated_at = CURRENT_TIMESTAMP;
              RETURN NEW;
          END;
          $$;


pg_restore: error: could not execute query: ERROR:  relation "account_order_access" already exists
Command was: CREATE TABLE public.account_order_access (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    order_id uuid NOT NULL,
    access_level character varying(50) DEFAULT 'view'::character varying NOT NULL,
    granted_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    granted_by uuid NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "accounts" already exists
Command was: CREATE TABLE public.accounts (
    id uuid NOT NULL,
    email character varying(255) NOT NULL,
    password character varying(255),
    contact_name character varying(255) NOT NULL,
    company_name character varying(255) NOT NULL,
    phone character varying(50),
    website character varying(255),
    tax_id character varying(100),
    billing_address text,
    billing_city character varying(100),
    billing_state character varying(100),
    billing_zip character varying(20),
    billing_country character varying(100),
    credit_terms character varying(50) DEFAULT 'prepay'::character varying,
    credit_limit bigint DEFAULT 0,
    primary_client_id uuid,
    status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    email_verified boolean DEFAULT false,
    email_verification_token character varying(255),
    reset_token character varying(255),
    reset_token_expiry timestamp without time zone,
    internal_notes text,
    order_preferences text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    last_login_at timestamp without time zone,
    onboarding_completed boolean DEFAULT false,
    onboarding_steps jsonb DEFAULT '{}'::jsonb,
    onboarding_completed_at timestamp without time zone,
    role character varying(50) DEFAULT 'viewer'::character varying NOT NULL,
    ai_permissions text DEFAULT '{}'::text,
    can_use_ai_keywords boolean DEFAULT false,
    can_use_ai_descriptions boolean DEFAULT false,
    can_use_ai_content_generation boolean DEFAULT false,
    google_id character varying(255),
    oauth_providers text DEFAULT '[]'::text,
    auth_method character varying(20) DEFAULT 'password'::character varying
);


pg_restore: error: could not execute query: ERROR:  relation "agent_sessions" already exists
Command was: CREATE TABLE public.agent_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    step_id character varying(100) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    agent_id character varying(255),
    conversation_id character varying(255),
    total_sections integer DEFAULT 0,
    completed_sections integer DEFAULT 0,
    target_word_count integer,
    current_word_count integer DEFAULT 0,
    outline text,
    session_metadata jsonb,
    error_message text,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    agent_profile character varying(50) DEFAULT 'narrative-focused'::character varying
);


pg_restore: error: could not execute query: ERROR:  relation "airtable_sync_config" already exists
Command was: CREATE TABLE public.airtable_sync_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key character varying(255) NOT NULL,
    value text NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "airtable_webhook_events" already exists
Command was: CREATE TABLE public.airtable_webhook_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    webhook_id character varying(255) NOT NULL,
    event_type character varying(100) NOT NULL,
    table_id character varying(255) NOT NULL,
    record_id character varying(255) NOT NULL,
    payload jsonb NOT NULL,
    processed boolean DEFAULT false,
    processed_at timestamp without time zone,
    error text,
    received_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "article_sections" already exists
Command was: CREATE TABLE public.article_sections (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    section_number integer NOT NULL,
    title character varying(255) NOT NULL,
    content text,
    word_count integer DEFAULT 0,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    agent_conversation_id character varying(255),
    generation_metadata jsonb,
    error_message text,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL,
    version integer DEFAULT 1 NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "audit_sections" already exists
Command was: CREATE TABLE public.audit_sections (
    id uuid NOT NULL,
    audit_session_id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    section_number integer NOT NULL,
    title character varying(255) NOT NULL,
    original_content text,
    audited_content text,
    strengths text,
    weaknesses text,
    editing_pattern character varying(100),
    citations_added integer DEFAULT 0,
    proceed_content text,
    cleanup_content text,
    proceed_status character varying(50) DEFAULT 'pending'::character varying,
    cleanup_status character varying(50) DEFAULT 'pending'::character varying,
    brand_compliance_score integer,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    audit_metadata jsonb,
    error_message text,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "audit_sessions" already exists
Command was: CREATE TABLE public.audit_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    step_id character varying(100) NOT NULL,
    audit_type character varying(50) DEFAULT NULL::character varying,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    total_sections integer DEFAULT 0,
    completed_sections integer DEFAULT 0,
    total_citations_used integer DEFAULT 0,
    total_proceed_steps integer DEFAULT 0,
    completed_proceed_steps integer DEFAULT 0,
    total_cleanup_steps integer DEFAULT 0,
    completed_cleanup_steps integer DEFAULT 0,
    original_article text,
    research_outline text,
    audit_metadata jsonb,
    error_message text,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "benchmark_comparisons" already exists
Command was: CREATE TABLE public.benchmark_comparisons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    benchmark_id uuid NOT NULL,
    order_id uuid NOT NULL,
    compared_at timestamp without time zone DEFAULT now() NOT NULL,
    compared_by uuid,
    comparison_data jsonb NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "bulk_analysis_domains" already exists
Command was: CREATE TABLE public.bulk_analysis_domains (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid NOT NULL,
    domain character varying(255) NOT NULL,
    qualification_status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    target_page_ids jsonb DEFAULT '[]'::jsonb NOT NULL,
    keyword_count integer DEFAULT 0,
    checked_by uuid,
    checked_at timestamp without time zone,
    notes text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    dataforseo_status character varying(50) DEFAULT 'pending'::character varying,
    dataforseo_keywords_found integer DEFAULT 0,
    dataforseo_analyzed_at timestamp without time zone,
    has_workflow boolean DEFAULT false,
    workflow_id uuid,
    workflow_created_at timestamp without time zone,
    dataforseo_searched_keywords text[] DEFAULT '{}'::text[],
    dataforseo_last_full_analysis_at timestamp without time zone,
    dataforseo_total_api_calls integer DEFAULT 0,
    dataforseo_incremental_api_calls integer DEFAULT 0,
    has_dataforseo_results boolean DEFAULT false,
    dataforseo_last_analyzed timestamp without time zone,
    ai_qualification_reasoning text,
    ai_qualified_at timestamp without time zone,
    was_manually_qualified boolean DEFAULT false,
    manually_qualified_by uuid,
    manually_qualified_at timestamp without time zone,
    was_human_verified boolean DEFAULT false,
    human_verified_by uuid,
    human_verified_at timestamp without time zone,
    dataforseo_results_count integer DEFAULT 0,
    project_id uuid,
    project_added_at timestamp without time zone,
    selected_target_page_id uuid,
    overlap_status character varying(10),
    authority_direct character varying(10),
    authority_related character varying(10),
    topic_scope character varying(20),
    topic_reasoning text,
    evidence json,
    airtable_record_id character varying(255),
    airtable_metadata jsonb,
    airtable_last_synced timestamp without time zone,
    duplicate_of uuid,
    duplicate_resolution character varying(50),
    duplicate_resolved_by uuid,
    duplicate_resolved_at timestamp without time zone,
    original_project_id uuid,
    resolution_metadata jsonb,
    normalized_domain character varying(255),
    suggested_target_url text,
    target_match_data jsonb,
    target_matched_at timestamp without time zone,
    CONSTRAINT bulk_analysis_domains_duplicate_resolution_check CHECK (((duplicate_resolution)::text = ANY ((ARRAY['keep_both'::character varying, 'move_to_new'::character varying, 'skip'::character varying, 'update_original'::character varying])::text[])))
);


pg_restore: error: could not execute query: ERROR:  relation "bulk_analysis_projects" already exists
Command was: CREATE TABLE public.bulk_analysis_projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    color character varying(7) DEFAULT '#6366f1'::character varying,
    icon character varying(50) DEFAULT 'ðŸ“'::character varying,
    status character varying(50) DEFAULT 'active'::character varying,
    auto_apply_keywords jsonb,
    tags jsonb DEFAULT '[]'::jsonb,
    domain_count integer DEFAULT 0,
    qualified_count integer DEFAULT 0,
    workflow_count integer DEFAULT 0,
    last_activity_at timestamp without time zone,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "bulk_dataforseo_job_items" already exists
Command was: CREATE TABLE public.bulk_dataforseo_job_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_id uuid,
    domain_id uuid,
    status character varying(50) DEFAULT 'pending'::character varying,
    keywords_analyzed integer,
    rankings_found integer,
    error_message text,
    processed_at timestamp without time zone
);


pg_restore: error: could not execute query: ERROR:  relation "bulk_dataforseo_jobs" already exists
Command was: CREATE TABLE public.bulk_dataforseo_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid,
    status character varying(50) DEFAULT 'pending'::character varying,
    total_domains integer,
    processed_domains integer DEFAULT 0,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "client_assignments" already exists
Command was: CREATE TABLE public.client_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid NOT NULL,
    user_id uuid NOT NULL,
    assigned_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "clients" already exists
Command was: CREATE TABLE public.clients (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(255) NOT NULL,
    website character varying(255),
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    description text DEFAULT ''::text,
    client_type character varying(50) DEFAULT 'client'::character varying,
    converted_from_prospect_at timestamp without time zone,
    conversion_notes text,
    default_requirements jsonb DEFAULT '{}'::jsonb,
    account_id uuid,
    share_token character varying(255),
    invitation_id uuid,
    archived_at timestamp without time zone,
    archived_by uuid,
    archive_reason text
);


pg_restore: error: could not execute query: ERROR:  relation "commission_configurations" already exists
Command was: CREATE TABLE public.commission_configurations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    scope_type character varying(50) NOT NULL,
    scope_id uuid,
    commission_type character varying(50) NOT NULL,
    base_commission_percent numeric(5,2),
    tier_rules jsonb DEFAULT '[]'::jsonb,
    rush_order_commission_percent numeric(5,2),
    bulk_order_commission_percent numeric(5,2),
    valid_from date DEFAULT CURRENT_DATE NOT NULL,
    valid_until date,
    is_active boolean DEFAULT true,
    notes text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by uuid NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "cron_jobs" already exists
Command was: CREATE TABLE public.cron_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(255) NOT NULL,
    type character varying(50) NOT NULL,
    schedule character varying(100) NOT NULL,
    enabled boolean DEFAULT true,
    last_run_at timestamp without time zone,
    next_run_at timestamp without time zone,
    last_run_status character varying(50),
    last_run_error text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "dataforseo_api_logs" already exists
Command was: CREATE TABLE public.dataforseo_api_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    task_id character varying(255),
    endpoint text NOT NULL,
    request_payload jsonb NOT NULL,
    request_headers jsonb,
    domain_id uuid,
    client_id uuid,
    domain character varying(255),
    response_status integer,
    response_data jsonb,
    error_message text,
    cost numeric(10,6),
    keyword_count integer,
    location_code integer,
    language_code character varying(10),
    requested_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    responded_at timestamp without time zone,
    request_type character varying(50),
    user_id uuid
);


pg_restore: error: could not execute query: ERROR:  relation "domain_suggestions" already exists
Command was: CREATE TABLE public.domain_suggestions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    account_id uuid,
    account_email character varying(255),
    domain_id uuid NOT NULL,
    order_id uuid,
    match_score integer,
    match_reasons text[],
    retail_price integer NOT NULL,
    suggested_by uuid NOT NULL,
    suggested_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    expires_at timestamp without time zone,
    status character varying(50) DEFAULT 'pending'::character varying,
    viewed_at timestamp without time zone,
    response_at timestamp without time zone,
    account_notes text,
    CONSTRAINT domain_suggestions_match_score_check CHECK (((match_score >= 0) AND (match_score <= 100)))
);


pg_restore: error: could not execute query: ERROR:  relation "duplicate_websites" already exists
Command was: CREATE VIEW public.duplicate_websites AS
 SELECT normalized_domain,
    count(*) AS duplicate_count,
    array_agg(id ORDER BY created_at) AS website_ids,
    array_agg(domain ORDER BY created_at) AS original_domains,
    min(created_at) AS first_created,
    max(created_at) AS last_created
   FROM public.websites
  WHERE (normalized_domain IS NOT NULL)
  GROUP BY normalized_domain
 HAVING (count(*) > 1)
  ORDER BY (count(*)) DESC;


pg_restore: error: could not execute query: ERROR:  relation "email_logs" already exists
Command was: CREATE TABLE public.email_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    type character varying(50) NOT NULL,
    recipients text[] NOT NULL,
    subject character varying(255) NOT NULL,
    status character varying(20) NOT NULL,
    sent_at timestamp without time zone,
    error text,
    resend_id character varying(255),
    metadata jsonb,
    sent_by uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "email_processing_logs" already exists
Command was: CREATE TABLE public.email_processing_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    webhook_id character varying(255),
    campaign_id character varying(255),
    campaign_name character varying(255),
    campaign_type character varying(50),
    email_from character varying(255) NOT NULL,
    email_to character varying(255),
    email_subject character varying(500),
    email_message_id character varying(255),
    received_at timestamp without time zone,
    raw_content text NOT NULL,
    html_content text,
    parsed_data jsonb DEFAULT '{}'::jsonb,
    confidence_score numeric(3,2),
    parsing_errors text[],
    status character varying(50) DEFAULT 'pending'::character varying,
    error_message text,
    processed_at timestamp without time zone,
    processing_duration_ms integer,
    thread_id character varying(255),
    reply_count integer DEFAULT 0,
    is_auto_reply boolean DEFAULT false,
    original_outreach_id uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    sender_email character varying(255)
);


pg_restore: error: could not execute query: ERROR:  relation "email_review_queue" already exists
Command was: CREATE TABLE public.email_review_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    log_id uuid,
    publisher_id uuid,
    priority integer DEFAULT 50,
    status character varying(50) DEFAULT 'pending'::character varying,
    queue_reason character varying(100),
    suggested_actions jsonb DEFAULT '{}'::jsonb,
    missing_fields text[],
    review_notes text,
    corrections_made jsonb DEFAULT '{}'::jsonb,
    assigned_to uuid,
    reviewed_by uuid,
    reviewed_at timestamp without time zone,
    auto_approve_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_checks" already exists
Command was: CREATE TABLE public.formatting_qa_checks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    qa_session_id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    check_number integer NOT NULL,
    check_type character varying(255) NOT NULL,
    check_description text,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    issues_found text,
    location_details text,
    confidence_score integer,
    fix_suggestions text,
    check_metadata jsonb,
    error_message text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_sessions" already exists
Command was: CREATE TABLE public.formatting_qa_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    step_id character varying(100) DEFAULT 'formatting-qa'::character varying NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    total_checks integer DEFAULT 0,
    passed_checks integer DEFAULT 0,
    failed_checks integer DEFAULT 0,
    original_article text,
    qa_metadata jsonb,
    error_message text,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    cleaned_article text,
    fixes_applied jsonb
);


pg_restore: error: could not execute query: ERROR:  relation "guest_post_items" already exists
Command was: CREATE TABLE public.guest_post_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    domain_id uuid NOT NULL,
    domain character varying(255) NOT NULL,
    domain_rating integer,
    traffic integer,
    retail_price integer NOT NULL,
    wholesale_price integer NOT NULL,
    workflow_id uuid,
    workflow_status character varying(50),
    workflow_created_at timestamp without time zone,
    workflow_completed_at timestamp without time zone,
    published_url character varying(500),
    published_at timestamp without time zone,
    publication_verified boolean DEFAULT false,
    has_issues boolean DEFAULT false,
    issue_notes text,
    issue_resolved_at timestamp without time zone,
    status character varying(50) DEFAULT 'pending'::character varying,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    target_page_id uuid,
    order_group_id uuid,
    site_selection_id uuid
);


pg_restore: error: could not execute query: ERROR:  relation "invitations" already exists
Command was: CREATE TABLE public.invitations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email character varying(255) NOT NULL,
    role character varying(50) NOT NULL,
    token character varying(255) NOT NULL,
    expires_at timestamp without time zone NOT NULL,
    used_at timestamp without time zone,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    revoked_at timestamp without time zone,
    created_by_email character varying(255) DEFAULT 'admin@system.com'::character varying NOT NULL,
    target_table character varying(20) DEFAULT 'accounts'::character varying NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "invoices" already exists
Command was: CREATE TABLE public.invoices (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    payment_id uuid,
    invoice_number character varying(50) NOT NULL,
    status character varying(20) DEFAULT 'draft'::character varying NOT NULL,
    subtotal integer NOT NULL,
    tax integer DEFAULT 0,
    discount integer DEFAULT 0,
    total integer NOT NULL,
    issue_date timestamp without time zone DEFAULT now() NOT NULL,
    due_date timestamp without time zone NOT NULL,
    paid_date timestamp without time zone,
    file_url character varying(500),
    sent_at timestamp without time zone,
    sent_to character varying(255),
    line_items jsonb NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "keyword_analysis_batches" already exists
Command was: CREATE TABLE public.keyword_analysis_batches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bulk_analysis_domain_id uuid NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    keywords_analyzed integer DEFAULT 0,
    location_code integer DEFAULT 2840 NOT NULL,
    language_code character varying(10) DEFAULT 'en'::character varying NOT NULL,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    error_message text,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "keyword_analysis_results" already exists
Command was: CREATE TABLE public.keyword_analysis_results (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bulk_analysis_domain_id uuid NOT NULL,
    keyword text NOT NULL,
    "position" integer NOT NULL,
    search_volume integer,
    url text NOT NULL,
    keyword_difficulty integer,
    cpc numeric(10,2),
    competition character varying(20),
    location_code integer DEFAULT 2840 NOT NULL,
    language_code character varying(10) DEFAULT 'en'::character varying NOT NULL,
    analysis_date timestamp without time zone NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    analysis_batch_id uuid,
    is_incremental boolean DEFAULT false
);


pg_restore: error: could not execute query: ERROR:  relation "keyword_search_history" already exists
Command was: CREATE TABLE public.keyword_search_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bulk_analysis_domain_id uuid NOT NULL,
    keyword text NOT NULL,
    location_code integer DEFAULT 2840 NOT NULL,
    language_code character varying(10) DEFAULT 'en'::character varying NOT NULL,
    has_results boolean DEFAULT false NOT NULL,
    searched_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "line_item_changes" already exists
Command was: CREATE TABLE public.line_item_changes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    line_item_id uuid NOT NULL,
    changed_by uuid NOT NULL,
    changed_at timestamp without time zone DEFAULT now() NOT NULL,
    change_reason text,
    order_id uuid NOT NULL,
    change_type character varying(50) NOT NULL,
    previous_value jsonb,
    batch_id uuid,
    metadata jsonb,
    new_value jsonb
);


pg_restore: error: could not execute query: ERROR:  relation "line_item_templates" already exists
Command was: CREATE TABLE public.line_item_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    default_anchor_text text,
    default_instructions text,
    pricing_rules jsonb,
    created_by uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "link_orchestration_sessions" already exists
Command was: CREATE TABLE public.link_orchestration_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    status character varying(50) NOT NULL,
    current_phase integer DEFAULT 1,
    phase1_start timestamp without time zone,
    phase1_complete timestamp without time zone,
    phase2_start timestamp without time zone,
    phase2_complete timestamp without time zone,
    phase3_start timestamp without time zone,
    phase3_complete timestamp without time zone,
    original_article text NOT NULL,
    article_after_phase1 text,
    article_after_phase2 text,
    final_article text,
    target_domain text NOT NULL,
    client_name character varying(255) NOT NULL,
    client_url text NOT NULL,
    anchor_text character varying(255),
    guest_post_site text NOT NULL,
    target_keyword character varying(255) NOT NULL,
    phase1_results jsonb,
    phase2_results jsonb,
    phase3_results jsonb,
    error_message text,
    error_details jsonb,
    started_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    completed_at timestamp without time zone,
    failed_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    internal_links_result jsonb,
    client_mention_result jsonb,
    client_link_result jsonb,
    client_link_conversation jsonb,
    image_strategy jsonb,
    link_requests text,
    url_suggestion text
);


pg_restore: error: could not execute query: ERROR:  relation "linkio_assets" already exists
Command was: CREATE TABLE public.linkio_assets (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    page_id uuid NOT NULL,
    asset_type character varying(50) NOT NULL,
    original_url text NOT NULL,
    description text,
    alt_text text,
    needs_recreation boolean DEFAULT true,
    our_url text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "linkio_blog_categories" already exists
Command was: CREATE TABLE public.linkio_blog_categories (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    category_name character varying(100) NOT NULL,
    category_slug character varying(100) NOT NULL,
    post_count integer DEFAULT 0,
    description text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "linkio_components" already exists
Command was: CREATE TABLE public.linkio_components (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    page_id uuid NOT NULL,
    component_type character varying(50) NOT NULL,
    component_name character varying(255),
    original_content jsonb,
    our_content jsonb,
    is_recreated boolean DEFAULT false,
    notes text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "linkio_pages" already exists
Command was: CREATE TABLE public.linkio_pages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    original_url text NOT NULL,
    original_title text,
    original_meta_description text,
    page_type public.page_type DEFAULT 'other'::public.page_type NOT NULL,
    category character varying(100),
    priority integer DEFAULT 0,
    recreation_status public.recreation_status DEFAULT 'identified'::public.recreation_status NOT NULL,
    our_slug character varying(255),
    our_title text,
    our_meta_description text,
    content_structure jsonb,
    key_features jsonb,
    word_count integer,
    has_video boolean DEFAULT false,
    has_tools boolean DEFAULT false,
    has_cta boolean DEFAULT true,
    notes text,
    skip_reason text,
    identified_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    analyzed_at timestamp without time zone,
    completed_at timestamp without time zone,
    published_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "master_qualification_job_items" already exists
Command was: CREATE TABLE public.master_qualification_job_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    job_id uuid,
    domain_id uuid,
    domain character varying(255) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying,
    stage character varying(50),
    dataforseo_status character varying(50),
    ai_status character varying(50),
    qualification_status character varying(50),
    keywords_found integer,
    error_message text,
    processed_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "master_qualification_jobs" already exists
Command was: CREATE TABLE public.master_qualification_jobs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid,
    status character varying(50) DEFAULT 'pending'::character varying,
    total_domains integer NOT NULL,
    processed_domains integer DEFAULT 0,
    dataforseo_completed integer DEFAULT 0,
    ai_completed integer DEFAULT 0,
    failed_domains integer DEFAULT 0,
    current_stage character varying(50),
    current_domain character varying(255),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    started_at timestamp without time zone,
    completed_at timestamp without time zone
);


pg_restore: error: could not execute query: ERROR:  relation "migration_history" already exists
Command was: CREATE TABLE public.migration_history (
    id integer NOT NULL,
    migration_name character varying(255) NOT NULL,
    executed_at timestamp without time zone DEFAULT now() NOT NULL,
    execution_time_ms integer,
    success boolean DEFAULT true NOT NULL,
    error_message text,
    applied_by character varying(255)
);


pg_restore: error: could not execute query: ERROR:  relation "migration_history_id_seq" already exists
Command was: CREATE SEQUENCE public.migration_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


pg_restore: error: could not execute query: ERROR:  relation "migrations" already exists
Command was: CREATE TABLE public.migrations (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    applied_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    error text
);


pg_restore: error: could not execute query: ERROR:  relation "migrations_id_seq" already exists
Command was: CREATE SEQUENCE public.migrations_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


pg_restore: error: could not execute query: ERROR:  relation "order_benchmarks" already exists
Command was: CREATE TABLE public.order_benchmarks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    benchmark_type character varying(50) NOT NULL,
    benchmark_data jsonb NOT NULL,
    created_by uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_active boolean DEFAULT true,
    notes text,
    captured_by uuid NOT NULL,
    capture_reason character varying(50) NOT NULL,
    captured_at timestamp without time zone DEFAULT now() NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    is_latest boolean DEFAULT true NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "order_groups" already exists
Command was: CREATE TABLE public.order_groups (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    client_id uuid NOT NULL,
    link_count integer NOT NULL,
    target_pages jsonb DEFAULT '[]'::jsonb,
    anchor_texts jsonb DEFAULT '[]'::jsonb,
    requirement_overrides jsonb DEFAULT '{}'::jsonb,
    bulk_analysis_project_id uuid,
    analysis_started_at timestamp without time zone,
    analysis_completed_at timestamp without time zone,
    group_status character varying(50) DEFAULT 'pending'::character varying,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "order_line_items" already exists
Command was: CREATE TABLE public.order_line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    client_id uuid NOT NULL,
    target_page_id uuid,
    target_page_url text,
    anchor_text text,
    assigned_domain_id uuid,
    assigned_domain character varying(255),
    estimated_price integer,
    wholesale_price integer,
    approved_price integer,
    status character varying(50) DEFAULT 'draft'::character varying,
    workflow_id uuid,
    draft_url text,
    published_url text,
    delivered_at timestamp without time zone,
    metadata jsonb DEFAULT '{}'::jsonb,
    added_by_user_id uuid,
    approved_by_user_id uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    publisher_id uuid,
    publisher_offering_id uuid,
    publisher_status character varying(50) DEFAULT NULL::character varying,
    publisher_price integer,
    platform_fee integer,
    publisher_notified_at timestamp without time zone,
    publisher_accepted_at timestamp without time zone,
    publisher_submitted_at timestamp without time zone,
    publisher_paid_at timestamp without time zone,
    assigned_at timestamp without time zone,
    assigned_by uuid,
    service_fee integer DEFAULT 7900,
    final_price integer,
    client_review_status character varying(20),
    client_reviewed_at timestamp without time zone,
    client_review_notes text,
    delivery_notes text,
    added_at timestamp without time zone DEFAULT now() NOT NULL,
    added_by uuid NOT NULL,
    modified_at timestamp without time zone,
    modified_by uuid,
    cancelled_at timestamp without time zone,
    cancelled_by uuid,
    cancellation_reason text,
    display_order integer DEFAULT 0 NOT NULL,
    version integer DEFAULT 1 NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "order_share_tokens" already exists
Command was: CREATE TABLE public.order_share_tokens (
    token character varying(255) NOT NULL,
    order_id uuid NOT NULL,
    permissions text[] DEFAULT ARRAY['view'::text],
    expires_at timestamp without time zone NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    used_at timestamp without time zone,
    used_by_ip character varying(45),
    use_count integer DEFAULT 0
);


pg_restore: error: could not execute query: ERROR:  relation "order_site_selections" already exists
Command was: CREATE TABLE public.order_site_selections (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_group_id uuid NOT NULL,
    domain_id uuid NOT NULL,
    status character varying(50) DEFAULT 'suggested'::character varying NOT NULL,
    target_page_url text,
    anchor_text character varying(255),
    reviewed_at timestamp without time zone,
    reviewed_by uuid,
    client_notes text,
    internal_notes text,
    order_item_id uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "order_site_submissions" already exists
Command was: CREATE TABLE public.order_site_submissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_group_id uuid NOT NULL,
    domain_id uuid NOT NULL,
    submission_status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    submitted_at timestamp without time zone,
    submitted_by uuid,
    client_reviewed_at timestamp without time zone,
    client_review_notes text,
    published_url text,
    published_at timestamp without time zone,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    client_reviewed_by uuid,
    completed_at timestamp without time zone,
    selection_pool character varying(20) DEFAULT 'primary'::character varying,
    pool_rank integer DEFAULT 1,
    wholesale_price_snapshot integer,
    retail_price_snapshot integer,
    service_fee_snapshot integer DEFAULT 7900,
    price_snapshot_at timestamp without time zone,
    inclusion_status character varying(50) DEFAULT 'included'::character varying,
    inclusion_order integer,
    exclusion_reason text
);


pg_restore: error: could not execute query: ERROR:  relation "order_status_history" already exists
Command was: CREATE TABLE public.order_status_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    old_status character varying(50),
    new_status character varying(50) NOT NULL,
    changed_by uuid NOT NULL,
    changed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    notes text
);


pg_restore: error: could not execute query: ERROR:  relation "order_summary" already exists
Command was: CREATE VIEW public.order_summary AS
SELECT
    NULL::uuid AS id,
    NULL::uuid AS account_id,
    NULL::character varying(50) AS state,
    NULL::character varying(50) AS status,
    NULL::integer AS total_retail,
    NULL::bigint AS client_count,
    NULL::bigint AS total_links,
    NULL::bigint AS approved_sites,
    NULL::timestamp without time zone AS created_at,
    NULL::timestamp without time zone AS updated_at;


pg_restore: error: could not execute query: ERROR:  relation "orders" already exists
Command was: CREATE TABLE public.orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    account_id uuid,
    status character varying(50) DEFAULT 'draft'::character varying NOT NULL,
    subtotal_retail integer DEFAULT 0 NOT NULL,
    discount_percent numeric(5,2) DEFAULT 0,
    discount_amount integer DEFAULT 0 NOT NULL,
    total_retail integer DEFAULT 0 NOT NULL,
    total_wholesale integer DEFAULT 0 NOT NULL,
    profit_margin integer DEFAULT 0 NOT NULL,
    includes_client_review boolean DEFAULT false,
    client_review_fee integer DEFAULT 0,
    rush_delivery boolean DEFAULT false,
    rush_fee integer DEFAULT 0,
    share_token character varying(255),
    share_expires_at timestamp without time zone,
    approved_at timestamp without time zone,
    invoiced_at timestamp without time zone,
    paid_at timestamp without time zone,
    completed_at timestamp without time zone,
    cancelled_at timestamp without time zone,
    created_by uuid NOT NULL,
    assigned_to uuid,
    internal_notes text,
    account_notes text,
    cancellation_reason text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    state character varying(50) DEFAULT 'configuring'::character varying,
    requires_client_review boolean DEFAULT false,
    review_completed_at timestamp without time zone,
    order_type character varying(50) DEFAULT 'guest_post'::character varying NOT NULL,
    invoice_data jsonb,
    estimated_budget_min integer,
    estimated_budget_max integer,
    estimated_links_count integer,
    preferences_dr_min integer,
    preferences_dr_max integer,
    preferences_traffic_min integer,
    preferences_categories text[],
    preferences_types text[],
    preferences_niches text[],
    estimator_snapshot jsonb,
    estimated_price_per_link integer,
    actual_price_per_link integer,
    preference_match_score numeric(5,2),
    is_template boolean DEFAULT false,
    template_name character varying(255),
    copied_from_order_id uuid,
    refunded_at timestamp without time zone,
    partial_refund_amount integer,
    proposal_video_url text,
    proposal_message text,
    total_workflows integer DEFAULT 0,
    completed_workflows integer DEFAULT 0,
    workflow_completion_percentage numeric(5,2) DEFAULT 0,
    fulfillment_started_at timestamp without time zone,
    fulfillment_completed_at timestamp without time zone,
    ready_for_delivery boolean DEFAULT false,
    client_notified_at timestamp without time zone,
    delivered_at timestamp without time zone,
    CONSTRAINT orders_workflow_completion_percentage_check CHECK (((workflow_completion_percentage >= (0)::numeric) AND (workflow_completion_percentage <= (100)::numeric)))
);


pg_restore: error: could not execute query: ERROR:  relation "outline_sessions" already exists
Command was: CREATE TABLE public.outline_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    step_id character varying(100) DEFAULT 'deep-research'::character varying NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    outline_prompt text,
    clarification_questions jsonb,
    clarification_answers text,
    agent_state jsonb,
    research_instructions text,
    final_outline text,
    citations jsonb,
    session_metadata jsonb,
    error_message text,
    started_at timestamp with time zone NOT NULL,
    completed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    background_response_id character varying(255),
    polling_attempts integer DEFAULT 0,
    last_polled_at timestamp without time zone,
    is_active boolean DEFAULT false,
    last_sequence_number integer DEFAULT 0,
    connection_status character varying(50),
    stream_started_at timestamp without time zone,
    partial_content text
);


pg_restore: error: could not execute query: ERROR:  relation "password_reset_tokens" already exists
Command was: CREATE TABLE public.password_reset_tokens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    token character varying(255) NOT NULL,
    expires_at timestamp without time zone NOT NULL,
    used_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "payments" already exists
Command was: CREATE TABLE public.payments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    account_id uuid NOT NULL,
    amount integer NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying NOT NULL,
    status public.payment_status DEFAULT 'pending'::public.payment_status NOT NULL,
    method public.payment_method NOT NULL,
    transaction_id character varying(255),
    processor_response jsonb,
    notes character varying(1000),
    failure_reason character varying(500),
    recorded_by uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    processed_at timestamp without time zone,
    is_partial boolean DEFAULT false,
    remaining_amount integer,
    stripe_payment_intent_id character varying(255)
);


pg_restore: error: could not execute query: ERROR:  relation "polish_sections" already exists
Command was: CREATE TABLE public.polish_sections (
    id uuid NOT NULL,
    polish_session_id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    section_number integer NOT NULL,
    title character varying(500) NOT NULL,
    original_content text,
    polished_content text,
    strengths text,
    weaknesses text,
    brand_conflicts text,
    polish_approach text,
    engagement_score real,
    clarity_score real,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    polish_metadata jsonb,
    error_message text,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "polish_sessions" already exists
Command was: CREATE TABLE public.polish_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer DEFAULT 1 NOT NULL,
    step_id character varying(100) DEFAULT 'final-polish'::character varying NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    total_sections integer DEFAULT 0,
    completed_sections integer DEFAULT 0,
    original_article text,
    research_context text,
    brand_conflicts_found integer DEFAULT 0,
    polish_metadata jsonb,
    error_message text,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "pricing_rules" already exists
Command was: CREATE TABLE public.pricing_rules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid,
    name character varying(255) NOT NULL,
    min_quantity integer NOT NULL,
    max_quantity integer,
    discount_percent numeric(5,2) NOT NULL,
    valid_from timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    valid_until timestamp without time zone,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "project_order_associations" already exists
Command was: CREATE TABLE public.project_order_associations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    order_group_id uuid NOT NULL,
    project_id uuid NOT NULL,
    association_type character varying(50) DEFAULT 'primary'::character varying NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by uuid NOT NULL,
    notes jsonb
);


pg_restore: error: could not execute query: ERROR:  relation "project_websites" already exists
Command was: CREATE TABLE public.project_websites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    website_id uuid NOT NULL,
    added_by uuid NOT NULL,
    added_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    analysis_status character varying(50) DEFAULT 'pending'::character varying,
    dataforseo_data jsonb,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_automation_logs" already exists
Command was: CREATE TABLE public.publisher_automation_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email_log_id uuid,
    publisher_id uuid,
    action character varying(100) NOT NULL,
    action_status character varying(50) DEFAULT 'success'::character varying,
    previous_data jsonb,
    new_data jsonb,
    fields_updated text[],
    confidence numeric(3,2),
    match_method character varying(50),
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_earnings" already exists
Command was: CREATE TABLE public.publisher_earnings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    order_line_item_id uuid,
    order_id uuid,
    earning_type character varying(50) NOT NULL,
    amount bigint NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying,
    gross_amount bigint,
    platform_fee_percent numeric(5,2),
    platform_fee_amount bigint,
    net_amount bigint NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying,
    confirmed_at timestamp without time zone,
    payment_batch_id uuid,
    payment_method character varying(50),
    payment_reference character varying(255),
    paid_at timestamp without time zone,
    website_id uuid,
    description text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_email_claims" already exists
Command was: CREATE TABLE public.publisher_email_claims (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    website_id uuid NOT NULL,
    email_domain character varying(255) NOT NULL,
    verification_token character varying(255) NOT NULL,
    verification_sent_at timestamp without time zone,
    verified_at timestamp without time zone,
    status character varying(50) DEFAULT 'pending'::character varying,
    rejection_reason text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    claim_confidence character varying(50),
    claim_source character varying(100)
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_invoices" already exists
Command was: CREATE TABLE public.publisher_invoices (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    invoice_number character varying(100) NOT NULL,
    invoice_date date NOT NULL,
    due_date date,
    gross_amount integer NOT NULL,
    tax_amount integer DEFAULT 0,
    total_amount integer NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying,
    description text NOT NULL,
    line_items jsonb,
    notes text,
    invoice_file_url character varying(500),
    supporting_documents jsonb,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    reviewed_by uuid,
    reviewed_at timestamp without time zone,
    review_notes text,
    approved_by uuid,
    approved_at timestamp without time zone,
    approved_amount integer,
    paid_by uuid,
    paid_at timestamp without time zone,
    payment_method character varying(50),
    payment_reference character varying(255),
    payment_notes text,
    related_order_line_items jsonb,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT publisher_invoices_gross_amount_check CHECK ((gross_amount > 0)),
    CONSTRAINT publisher_invoices_total_amount_check CHECK ((total_amount > 0))
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_offering_relationships" already exists
Command was: CREATE TABLE public.publisher_offering_relationships (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    offering_id uuid,
    website_id uuid NOT NULL,
    is_primary boolean DEFAULT false,
    is_active boolean DEFAULT true,
    custom_terms jsonb DEFAULT '{}'::jsonb,
    verified_at timestamp without time zone,
    verified_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    relationship_type character varying(50) DEFAULT 'contact'::character varying NOT NULL,
    verification_status character varying(20) DEFAULT 'claimed'::character varying NOT NULL,
    priority_rank integer DEFAULT 100,
    is_preferred boolean DEFAULT false,
    verification_method character varying(50),
    contact_email character varying(255),
    contact_phone character varying(50),
    contact_name character varying(255),
    internal_notes text,
    publisher_notes text,
    commission_rate character varying(50),
    payment_terms character varying(255)
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_offerings" already exists
Command was: CREATE TABLE public.publisher_offerings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    offering_type character varying(50) NOT NULL,
    base_price integer NOT NULL,
    turnaround_days integer,
    min_word_count integer,
    max_word_count integer,
    niches text[],
    languages character varying(10)[] DEFAULT ARRAY['en'::text],
    attributes jsonb DEFAULT '{}'::jsonb,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    currency character varying(10) DEFAULT 'USD'::character varying NOT NULL,
    current_availability character varying(50) DEFAULT 'available'::character varying NOT NULL,
    express_available boolean DEFAULT false,
    express_price integer,
    express_days integer,
    offering_name character varying(255)
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_order_analytics" already exists
Command was: CREATE TABLE public.publisher_order_analytics (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    website_id uuid,
    period_type character varying(20) NOT NULL,
    period_date date NOT NULL,
    total_orders integer DEFAULT 0,
    pending_orders integer DEFAULT 0,
    completed_orders integer DEFAULT 0,
    cancelled_orders integer DEFAULT 0,
    gross_earnings bigint DEFAULT 0,
    platform_fees bigint DEFAULT 0,
    net_earnings bigint DEFAULT 0,
    paid_amount bigint DEFAULT 0,
    pending_payment bigint DEFAULT 0,
    avg_completion_days numeric(10,2),
    acceptance_rate numeric(5,2),
    on_time_rate numeric(5,2),
    quality_score numeric(5,2),
    orders_change_percent numeric(10,2),
    earnings_change_percent numeric(10,2),
    calculated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_order_notifications" already exists
Command was: CREATE TABLE public.publisher_order_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    order_line_item_id uuid,
    notification_type character varying(50) NOT NULL,
    channel character varying(50) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying,
    sent_at timestamp without time zone,
    delivered_at timestamp without time zone,
    read_at timestamp without time zone,
    subject character varying(500),
    message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    error_message text,
    retry_count integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_payment_batches" already exists
Command was: CREATE TABLE public.publisher_payment_batches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    batch_number character varying(50) NOT NULL,
    publisher_id uuid,
    payment_method character varying(50) NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying,
    total_earnings bigint NOT NULL,
    total_deductions bigint DEFAULT 0,
    net_amount bigint NOT NULL,
    status character varying(50) DEFAULT 'draft'::character varying,
    approved_by uuid,
    approved_at timestamp without time zone,
    payment_reference character varying(255),
    payment_notes text,
    paid_at timestamp without time zone,
    error_message text,
    retry_count integer DEFAULT 0,
    earnings_count integer DEFAULT 0,
    period_start date,
    period_end date,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    created_by uuid NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_payment_profiles" already exists
Command was: CREATE TABLE public.publisher_payment_profiles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    preferred_method character varying(50) DEFAULT 'bank_transfer'::character varying NOT NULL,
    bank_name character varying(255),
    bank_account_holder character varying(255),
    bank_account_number character varying(100),
    bank_routing_number character varying(50),
    bank_swift_code character varying(20),
    bank_address text,
    paypal_email character varying(255),
    mailing_address text,
    mailing_city character varying(100),
    mailing_state character varying(50),
    mailing_zip character varying(20),
    mailing_country character varying(50) DEFAULT 'US'::character varying,
    tax_id character varying(50),
    tax_form_type character varying(10),
    is_business boolean DEFAULT false,
    business_name character varying(255),
    minimum_payout_amount integer DEFAULT 5000,
    payment_frequency character varying(20) DEFAULT 'monthly'::character varying,
    preferred_payment_day integer DEFAULT 1,
    is_verified boolean DEFAULT false,
    verification_notes text,
    verified_at timestamp without time zone,
    verified_by uuid,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_payouts" already exists
Command was: CREATE TABLE public.publisher_payouts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    payout_period_start date NOT NULL,
    payout_period_end date NOT NULL,
    total_amount integer NOT NULL,
    commission_rate numeric(5,2) NOT NULL,
    commission_amount integer NOT NULL,
    net_amount integer NOT NULL,
    payment_method character varying(50),
    payment_reference character varying(255),
    payment_date timestamp without time zone,
    status character varying(50) DEFAULT 'pending'::character varying,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_performance" already exists
Command was: CREATE TABLE public.publisher_performance (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    website_id uuid,
    period_start date NOT NULL,
    period_end date NOT NULL,
    total_orders integer DEFAULT 0,
    successful_orders integer DEFAULT 0,
    failed_orders integer DEFAULT 0,
    avg_response_time_hours numeric(10,2),
    avg_turnaround_days numeric(10,2),
    on_time_delivery_rate numeric(5,2),
    client_satisfaction_score numeric(3,2),
    revenue_generated integer DEFAULT 0,
    commission_earned integer DEFAULT 0,
    reliability_score numeric(3,2),
    metrics jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    content_approval_rate numeric(5,2) DEFAULT 0,
    revision_rate numeric(5,2) DEFAULT 0,
    total_revenue integer DEFAULT 0,
    avg_order_value integer DEFAULT 0,
    last_calculated_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_pricing_rules" already exists
Command was: CREATE TABLE public.publisher_pricing_rules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_offering_id uuid NOT NULL,
    rule_type character varying(50) NOT NULL,
    rule_name character varying(255) NOT NULL,
    description text,
    conditions jsonb NOT NULL,
    actions jsonb NOT NULL,
    priority integer DEFAULT 0,
    is_cumulative boolean DEFAULT false,
    auto_apply boolean DEFAULT true,
    requires_approval boolean DEFAULT false,
    valid_from timestamp without time zone,
    valid_until timestamp without time zone,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "publisher_websites" already exists
Command was: CREATE TABLE public.publisher_websites (
    id uuid NOT NULL,
    publisher_id uuid NOT NULL,
    website_id uuid NOT NULL,
    can_edit_pricing boolean DEFAULT true,
    can_edit_availability boolean DEFAULT true,
    can_view_analytics boolean DEFAULT true,
    status character varying(20) DEFAULT 'active'::character varying,
    added_at timestamp without time zone DEFAULT now() NOT NULL,
    removed_at timestamp without time zone
);


pg_restore: error: could not execute query: ERROR:  relation "publishers" already exists
Command was: CREATE TABLE public.publishers (
    id uuid NOT NULL,
    email character varying(255) NOT NULL,
    password character varying(255),
    contact_name character varying(255) DEFAULT 'Unknown'::character varying NOT NULL,
    company_name character varying(255),
    phone character varying(50),
    tax_id character varying(100),
    payment_email character varying(255),
    payment_method character varying(50) DEFAULT 'paypal'::character varying,
    bank_name character varying(255),
    bank_account_number character varying(255),
    bank_routing_number character varying(255),
    commission_rate integer DEFAULT 40,
    minimum_payout bigint DEFAULT 10000,
    status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    email_verified boolean DEFAULT false,
    email_verification_token character varying(255),
    reset_token character varying(255),
    reset_token_expiry timestamp without time zone,
    content_guidelines text,
    prohibited_topics text,
    turnaround_time integer DEFAULT 7,
    internal_notes text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    last_login_at timestamp without time zone,
    google_id character varying(255),
    oauth_providers text DEFAULT '[]'::text,
    auth_method character varying(20) DEFAULT 'password'::character varying,
    account_status character varying(50) DEFAULT 'unclaimed'::character varying,
    source character varying(50) DEFAULT 'manual'::character varying,
    source_metadata jsonb DEFAULT '{}'::jsonb,
    claimed_at timestamp without time zone,
    invitation_token character varying(255),
    invitation_sent_at timestamp without time zone,
    invitation_expires_at timestamp without time zone,
    confidence_score numeric(3,2),
    claim_verification_code character varying(6),
    claim_attempts integer DEFAULT 0,
    last_claim_attempt timestamp without time zone,
    CONSTRAINT chk_account_status CHECK (((account_status)::text = ANY ((ARRAY['unclaimed'::character varying, 'shadow'::character varying, 'active'::character varying, 'system'::character varying, 'suspended'::character varying, 'blocked'::character varying])::text[]))),
    CONSTRAINT chk_claim_attempts CHECK ((claim_attempts >= 0)),
    CONSTRAINT chk_confidence_score CHECK (((confidence_score >= (0)::numeric) AND (confidence_score <= (1)::numeric)))
);


pg_restore: error: could not execute query: ERROR:  relation "refunds" already exists
Command was: CREATE TABLE public.refunds (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    payment_id uuid NOT NULL,
    order_id uuid NOT NULL,
    stripe_refund_id character varying(255) NOT NULL,
    amount integer NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying NOT NULL,
    status character varying(50) NOT NULL,
    reason character varying(50),
    notes text,
    failure_reason character varying(500),
    initiated_by uuid NOT NULL,
    metadata jsonb,
    processed_at timestamp without time zone,
    canceled_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "shadow_publisher_websites" already exists
Command was: CREATE TABLE public.shadow_publisher_websites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    publisher_id uuid NOT NULL,
    website_id uuid NOT NULL,
    confidence numeric(3,2),
    source character varying(50),
    extraction_method character varying(100),
    verified boolean DEFAULT false,
    verified_by uuid,
    verified_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now()
);


pg_restore: error: could not execute query: ERROR:  relation "stripe_customers" already exists
Command was: CREATE TABLE public.stripe_customers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    account_id uuid NOT NULL,
    stripe_customer_id character varying(255) NOT NULL,
    email character varying(255) NOT NULL,
    name character varying(255),
    billing_address jsonb,
    metadata jsonb,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "stripe_payment_intents" already exists
Command was: CREATE TABLE public.stripe_payment_intents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    payment_id uuid,
    stripe_payment_intent_id character varying(255) NOT NULL,
    stripe_customer_id character varying(255),
    amount integer NOT NULL,
    currency character varying(3) DEFAULT 'USD'::character varying NOT NULL,
    status character varying(50) NOT NULL,
    client_secret text NOT NULL,
    metadata jsonb,
    idempotency_key character varying(255),
    payment_method_id character varying(255),
    setup_future_usage character varying(50),
    confirmation_method character varying(50) DEFAULT 'automatic'::character varying,
    amount_capturable integer,
    amount_captured integer DEFAULT 0,
    amount_received integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    confirmed_at timestamp without time zone,
    succeeded_at timestamp without time zone,
    canceled_at timestamp without time zone,
    last_webhook_event_id character varying(255),
    last_error jsonb,
    failure_code character varying(100),
    failure_message text
);


pg_restore: error: could not execute query: ERROR:  relation "stripe_webhooks" already exists
Command was: CREATE TABLE public.stripe_webhooks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    stripe_event_id character varying(255) NOT NULL,
    event_type character varying(100) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    payment_intent_id uuid,
    order_id uuid,
    event_data jsonb NOT NULL,
    processed_at timestamp without time zone,
    error_message text,
    retry_count integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "target_pages" already exists
Command was: CREATE TABLE public.target_pages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    client_id uuid NOT NULL,
    url text NOT NULL,
    domain character varying(255) NOT NULL,
    status character varying(50) DEFAULT 'active'::character varying NOT NULL,
    notes text,
    added_at timestamp without time zone DEFAULT now() NOT NULL,
    completed_at timestamp without time zone,
    keywords text,
    description text,
    normalized_url character varying(500)
);


pg_restore: error: could not execute query: ERROR:  relation "user_client_access" already exists
Command was: CREATE TABLE public.user_client_access (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid NOT NULL,
    access_level character varying(50) DEFAULT 'viewer'::character varying,
    granted_by uuid,
    granted_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "user_website_access" already exists
Command was: CREATE TABLE public.user_website_access (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    website_id uuid NOT NULL,
    access_level character varying(50) DEFAULT 'publisher_member'::character varying,
    granted_by uuid,
    granted_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "users" already exists
Command was: CREATE TABLE public.users (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email character varying(255) NOT NULL,
    name character varying(255) NOT NULL,
    password_hash character varying(255),
    role character varying(50) DEFAULT 'user'::character varying NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    last_login timestamp without time zone,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    user_type character varying(20) DEFAULT 'internal'::character varying,
    google_id character varying(255),
    oauth_providers text DEFAULT '[]'::text,
    auth_method character varying(20) DEFAULT 'password'::character varying
);


pg_restore: error: could not execute query: ERROR:  relation "v2_agent_sessions" already exists
Command was: CREATE TABLE public.v2_agent_sessions (
    id uuid NOT NULL,
    workflow_id uuid NOT NULL,
    version integer NOT NULL,
    step_id character varying(50) NOT NULL,
    status character varying(50) NOT NULL,
    outline text,
    total_sections integer,
    completed_sections integer,
    current_word_count integer,
    total_word_count integer,
    final_article text,
    session_metadata jsonb,
    error_message text,
    started_at timestamp without time zone NOT NULL,
    completed_at timestamp without time zone,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "v_active_publisher_offerings" already exists
Command was: CREATE VIEW public.v_active_publisher_offerings AS
 SELECT po.id AS offering_id,
    po.publisher_id,
    p.company_name AS publisher_name,
    po.offering_type,
    po.base_price,
    po.turnaround_days,
    w.id AS website_id,
    w.domain,
    w.domain_rating,
    w.total_traffic,
    por.is_primary,
    por.verified_at
   FROM (((public.publisher_offerings po
     JOIN public.publisher_offering_relationships por ON ((po.id = por.offering_id)))
     JOIN public.websites w ON ((por.website_id = w.id)))
     JOIN public.publishers p ON ((por.publisher_id = p.id)))
  WHERE ((po.is_active = true) AND (por.is_active = true) AND ((p.status)::text = 'active'::text));


pg_restore: error: could not execute query: ERROR:  relation "v_publisher_performance_complete" already exists
Command was: CREATE VIEW public.v_publisher_performance_complete AS
 SELECT COALESCE(pp.publisher_id, p.id) AS publisher_id,
    w.id AS website_id,
    w.domain,
    pp.avg_response_time_hours AS response_time,
    pp.on_time_delivery_rate AS success_rate,
    pp.total_orders,
    pp.reliability_score,
    pp.client_satisfaction_score
   FROM (((public.websites w
     LEFT JOIN public.publisher_offering_relationships por ON ((w.id = por.website_id)))
     LEFT JOIN public.publishers p ON ((por.publisher_id = p.id)))
     LEFT JOIN public.publisher_performance pp ON (((p.id = pp.publisher_id) AND (w.id = pp.website_id))));


pg_restore: error: could not execute query: ERROR:  relation "webhook_security_logs" already exists
Command was: CREATE TABLE public.webhook_security_logs (
    id integer NOT NULL,
    webhook_id character varying(255),
    ip_address character varying(45) NOT NULL,
    user_agent text,
    signature_valid boolean DEFAULT false,
    signature_provided character varying(255),
    timestamp_valid boolean DEFAULT false,
    ip_allowed boolean DEFAULT false,
    rate_limit_key character varying(255),
    requests_in_window integer DEFAULT 1,
    allowed boolean DEFAULT false,
    rejection_reason text,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "webhook_security_logs_id_seq" already exists
Command was: CREATE SEQUENCE public.webhook_security_logs_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


pg_restore: error: could not execute query: ERROR:  relation "website_contacts" already exists
Command was: CREATE TABLE public.website_contacts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    website_id uuid NOT NULL,
    email character varying(255) NOT NULL,
    is_primary boolean DEFAULT false,
    has_paid_guest_post boolean DEFAULT false,
    has_swap_option boolean DEFAULT false,
    guest_post_cost numeric(10,2),
    link_insert_cost numeric(10,2),
    requirement character varying(50),
    status character varying(50) DEFAULT 'Active'::character varying,
    airtable_link_price_id character varying(255),
    last_contacted timestamp without time zone,
    response_rate numeric(5,2),
    average_response_time integer,
    notes text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "website_qualifications" already exists
Command was: CREATE TABLE public.website_qualifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    website_id uuid NOT NULL,
    client_id uuid NOT NULL,
    project_id uuid,
    qualified_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    qualified_by uuid NOT NULL,
    status character varying(50) DEFAULT 'qualified'::character varying,
    reason text,
    notes text,
    imported_from character varying(50) DEFAULT 'airtable'::character varying,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "website_sync_logs" already exists
Command was: CREATE TABLE public.website_sync_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    website_id uuid,
    sync_type character varying(50) NOT NULL,
    action character varying(50) NOT NULL,
    status character varying(50) NOT NULL,
    airtable_record_id character varying(255),
    changes jsonb,
    error text,
    started_at timestamp without time zone NOT NULL,
    completed_at timestamp without time zone,
    records_processed integer DEFAULT 0
);


pg_restore: error: could not execute query: ERROR:  relation "workflow_steps" already exists
Command was: CREATE TABLE public.workflow_steps (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    workflow_id uuid NOT NULL,
    step_id character varying(100) NOT NULL,
    title character varying(255) NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    inputs jsonb,
    outputs jsonb,
    completed_at timestamp without time zone,
    "position" integer NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    step_number integer DEFAULT 0 NOT NULL
);


pg_restore: error: could not execute query: ERROR:  relation "workflow_websites" already exists
Command was: CREATE TABLE public.workflow_websites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    workflow_id uuid NOT NULL,
    website_id uuid NOT NULL,
    step_added character varying(100) NOT NULL,
    usage_type character varying(50) NOT NULL,
    added_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


pg_restore: error: could not execute query: ERROR:  relation "workflows" already exists
Command was: CREATE TABLE public.workflows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid,
    title character varying(255) NOT NULL,
    status character varying(50) DEFAULT 'active'::character varying NOT NULL,
    content jsonb,
    target_pages jsonb,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    order_item_id uuid,
    completion_percentage numeric(5,2) DEFAULT 0,
    is_completed boolean DEFAULT false,
    completed_at timestamp without time zone,
    last_step_completed_at timestamp without time zone,
    last_active_at timestamp without time zone,
    assigned_user_id uuid,
    assigned_at timestamp without time zone,
    estimated_completion_date timestamp without time zone,
    publisher_email character varying(255),
    publisher_pre_approval_sent_at timestamp without time zone,
    publisher_pre_approval_status character varying(50),
    publisher_final_sent_at timestamp without time zone,
    published_url character varying(500),
    publication_verified_at timestamp without time zone,
    qa_checklist_completed boolean DEFAULT false,
    payment_authorized boolean DEFAULT false,
    payment_authorized_at timestamp without time zone,
    payment_amount numeric(10,2),
    CONSTRAINT workflows_completion_percentage_check CHECK (((completion_percentage >= (0)::numeric) AND (completion_percentage <= (100)::numeric))),
    CONSTRAINT workflows_publisher_pre_approval_status_check CHECK (((publisher_pre_approval_status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'revision_requested'::character varying])::text[])))
);


pg_restore: error: COPY failed for table "bulk_analysis_domains": ERROR:  function normalize_domain(character varying) does not exist
LINE 1: NEW.normalized_domain := normalize_domain(NEW.domain)
                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  NEW.normalized_domain := normalize_domain(NEW.domain)
CONTEXT:  PL/pgSQL function public.trigger_normalize_domain() line 3 at assignment
COPY bulk_analysis_domains, line 1: "d190db92-294c-4c4a-88d0-def7e9eeff50	4f48d013-bb1b-4271-884e-578e48e60459	linkio.com	high_quality	["..."
pg_restore: error: COPY failed for table "websites": ERROR:  function normalize_domain(character varying) does not exist
LINE 1: NEW.normalized_domain := normalize_domain(NEW.domain)
                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  NEW.normalized_domain := normalize_domain(NEW.domain)
CONTEXT:  PL/pgSQL function public.trigger_normalize_domain() line 3 at assignment
COPY websites, line 1: "9c93e004-3d2d-46e4-9a01-26d9d82bd425	\N	hellonuzzle.com	\N	\N	\N	{Other}	\N	Unknown	f	f	0	\N	2025-08..."
pg_restore: error: could not execute query: ERROR:  relation "accounts_google_id_key" already exists
Command was: ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_google_id_key UNIQUE (google_id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "account_order_access" are not allowed
Command was: ALTER TABLE ONLY public.account_order_access
    ADD CONSTRAINT advertiser_order_access_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "advertiser_order_access_user_id_order_id_key" already exists
Command was: ALTER TABLE ONLY public.account_order_access
    ADD CONSTRAINT advertiser_order_access_user_id_order_id_key UNIQUE (user_id, order_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "advertisers_email_key"
DETAIL:  Key (email)=(lucifermorningstar03112006@gmail.com) is duplicated.
Command was: ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT advertisers_email_key UNIQUE (email);


pg_restore: error: could not execute query: ERROR:  could not create unique index "advertisers_pkey"
DETAIL:  Key (id)=(90194503-ea32-4a26-ba0d-62f37e0ea818) is duplicated.
Command was: ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT advertisers_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "agent_sessions_pkey"
DETAIL:  Key (id)=(8cc886b5-ac19-456b-ae3e-9a3c273d8fb9) is duplicated.
Command was: ALTER TABLE ONLY public.agent_sessions
    ADD CONSTRAINT agent_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "airtable_sync_config_key_key" already exists
Command was: ALTER TABLE ONLY public.airtable_sync_config
    ADD CONSTRAINT airtable_sync_config_key_key UNIQUE (key);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "airtable_sync_config" are not allowed
Command was: ALTER TABLE ONLY public.airtable_sync_config
    ADD CONSTRAINT airtable_sync_config_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "airtable_webhook_events_pkey"
DETAIL:  Key (id)=(80e19d78-f990-404d-8619-a139d4a05b68) is duplicated.
Command was: ALTER TABLE ONLY public.airtable_webhook_events
    ADD CONSTRAINT airtable_webhook_events_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "article_sections_pkey"
DETAIL:  Key (id)=(5a4b5d6f-9cd6-49e9-ac86-04ad723cec1e) is duplicated.
Command was: ALTER TABLE ONLY public.article_sections
    ADD CONSTRAINT article_sections_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "audit_sections_pkey"
DETAIL:  Key (id)=(1d98f728-c52f-4471-ab18-b3e2adf85a53) is duplicated.
Command was: ALTER TABLE ONLY public.audit_sections
    ADD CONSTRAINT audit_sections_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "audit_sessions_pkey"
DETAIL:  Key (id)=(4616a487-bdc4-4e1c-aa2d-9b11b25f6735) is duplicated.
Command was: ALTER TABLE ONLY public.audit_sessions
    ADD CONSTRAINT audit_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "benchmark_comparisons_pkey"
DETAIL:  Key (id)=(b61ebed9-eb7e-4a28-8ed5-9f79b4191085) is duplicated.
Command was: ALTER TABLE ONLY public.benchmark_comparisons
    ADD CONSTRAINT benchmark_comparisons_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_analysis_domains_client_domain_unique"
DETAIL:  Key (client_id, domain)=(c4e987f4-0712-4e43-8b57-16a2c45e19b3, quicksilvertranslate.com) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_client_domain_unique UNIQUE (client_id, domain);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_analysis_domains_pkey"
DETAIL:  Key (id)=(a1a7c967-cd7b-417d-9c64-f90ce9acd763) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_analysis_projects_client_id_name_key"
DETAIL:  Key (client_id, name)=(4f48d013-bb1b-4271-884e-578e48e60459, Order #b26e956b - Linkio) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_analysis_projects
    ADD CONSTRAINT bulk_analysis_projects_client_id_name_key UNIQUE (client_id, name);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_analysis_projects_pkey"
DETAIL:  Key (id)=(b1cf2471-3851-4b7f-8608-2cc317cc9f4a) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_analysis_projects
    ADD CONSTRAINT bulk_analysis_projects_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_dataforseo_job_items_pkey"
DETAIL:  Key (id)=(985bcfea-8559-4c8d-bca3-92b6c619b552) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_dataforseo_job_items
    ADD CONSTRAINT bulk_dataforseo_job_items_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "bulk_dataforseo_jobs_pkey"
DETAIL:  Key (id)=(ab085d99-49c2-4a6f-ae09-3efc00e3098f) is duplicated.
Command was: ALTER TABLE ONLY public.bulk_dataforseo_jobs
    ADD CONSTRAINT bulk_dataforseo_jobs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "client_assignments_client_id_user_id_key" already exists
Command was: ALTER TABLE ONLY public.client_assignments
    ADD CONSTRAINT client_assignments_client_id_user_id_key UNIQUE (client_id, user_id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "client_assignments" are not allowed
Command was: ALTER TABLE ONLY public.client_assignments
    ADD CONSTRAINT client_assignments_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "clients_pkey"
DETAIL:  Key (id)=(429e5e11-30d6-4321-a622-ead30466dcef) is duplicated.
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "clients_share_token_key" already exists
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_share_token_key UNIQUE (share_token);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "commission_configurations" are not allowed
Command was: ALTER TABLE ONLY public.commission_configurations
    ADD CONSTRAINT commission_configurations_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "cron_jobs_pkey"
DETAIL:  Key (id)=(144f4cdb-88f4-49b3-bce6-783db513a042) is duplicated.
Command was: ALTER TABLE ONLY public.cron_jobs
    ADD CONSTRAINT cron_jobs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "dataforseo_api_logs_pkey"
DETAIL:  Key (id)=(ae443d9b-5d4c-4792-b4f0-6561a620d60f) is duplicated.
Command was: ALTER TABLE ONLY public.dataforseo_api_logs
    ADD CONSTRAINT dataforseo_api_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "domain_suggestions" are not allowed
Command was: ALTER TABLE ONLY public.domain_suggestions
    ADD CONSTRAINT domain_suggestions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "email_logs_pkey"
DETAIL:  Key (id)=(7fa8be63-ae10-49aa-b7e2-cb93f2da655c) is duplicated.
Command was: ALTER TABLE ONLY public.email_logs
    ADD CONSTRAINT email_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "email_processing_logs_pkey"
DETAIL:  Key (id)=(3ddcee44-22cd-4ce9-b04e-29359a7bface) is duplicated.
Command was: ALTER TABLE ONLY public.email_processing_logs
    ADD CONSTRAINT email_processing_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "email_review_queue" are not allowed
Command was: ALTER TABLE ONLY public.email_review_queue
    ADD CONSTRAINT email_review_queue_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "formatting_qa_checks_pkey"
DETAIL:  Key (id)=(a4eef6c6-8502-4842-958e-ba0530ad4b5f) is duplicated.
Command was: ALTER TABLE ONLY public.formatting_qa_checks
    ADD CONSTRAINT formatting_qa_checks_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "formatting_qa_sessions_pkey"
DETAIL:  Key (id)=(4c179b33-c6b9-4437-93eb-2100c9162b5d) is duplicated.
Command was: ALTER TABLE ONLY public.formatting_qa_sessions
    ADD CONSTRAINT formatting_qa_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "invitations_pkey"
DETAIL:  Key (id)=(54983aa5-3638-460e-aafe-a57e585897c2) is duplicated.
Command was: ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "invitations_token_key"
DETAIL:  Key (token)=(SHADAoYVxGQsaRk8SbuNlrb6-9eHUw1jKipAravtfz8) is duplicated.
Command was: ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_token_key UNIQUE (token);


pg_restore: error: could not execute query: ERROR:  relation "invoices_invoice_number_key" already exists
Command was: ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "invoices" are not allowed
Command was: ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "keyword_analysis_batches" are not allowed
Command was: ALTER TABLE ONLY public.keyword_analysis_batches
    ADD CONSTRAINT keyword_analysis_batches_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "keyword_analysis_results_pkey"
DETAIL:  Key (id)=(725a587c-d754-4293-943b-45b54ea7ee8b) is duplicated.
CONTEXT:  parallel worker
Command was: ALTER TABLE ONLY public.keyword_analysis_results
    ADD CONSTRAINT keyword_analysis_results_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "keyword_search_history_bulk_analysis_domain_id_keyword_loca_key"
DETAIL:  Key (bulk_analysis_domain_id, keyword, location_code, language_code)=(c271dc8d-638b-4a33-b317-89741198ca82, analytics, 2840, en) is duplicated.
Command was: ALTER TABLE ONLY public.keyword_search_history
    ADD CONSTRAINT keyword_search_history_bulk_analysis_domain_id_keyword_loca_key UNIQUE (bulk_analysis_domain_id, keyword, location_code, language_code);


pg_restore: error: could not execute query: ERROR:  could not create unique index "keyword_search_history_pkey"
DETAIL:  Key (id)=(96296314-6dc4-4fa9-82f0-031d434d8f62) is duplicated.
CONTEXT:  parallel worker
Command was: ALTER TABLE ONLY public.keyword_search_history
    ADD CONSTRAINT keyword_search_history_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "line_item_changes_pkey"
DETAIL:  Key (id)=(472450c2-c6b2-4e1b-8d9e-30dac96a1415) is duplicated.
Command was: ALTER TABLE ONLY public.line_item_changes
    ADD CONSTRAINT line_item_changes_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "line_item_templates" are not allowed
Command was: ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT line_item_templates_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "link_orchestration_sessions_pkey"
DETAIL:  Key (id)=(d6b90a41-5413-497f-9396-00d8b662f25a) is duplicated.
Command was: ALTER TABLE ONLY public.link_orchestration_sessions
    ADD CONSTRAINT link_orchestration_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "linkio_assets" are not allowed
Command was: ALTER TABLE ONLY public.linkio_assets
    ADD CONSTRAINT linkio_assets_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "linkio_blog_categories_category_name_key" already exists
Command was: ALTER TABLE ONLY public.linkio_blog_categories
    ADD CONSTRAINT linkio_blog_categories_category_name_key UNIQUE (category_name);


pg_restore: error: could not execute query: ERROR:  relation "linkio_blog_categories_category_slug_key" already exists
Command was: ALTER TABLE ONLY public.linkio_blog_categories
    ADD CONSTRAINT linkio_blog_categories_category_slug_key UNIQUE (category_slug);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "linkio_blog_categories" are not allowed
Command was: ALTER TABLE ONLY public.linkio_blog_categories
    ADD CONSTRAINT linkio_blog_categories_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "linkio_components" are not allowed
Command was: ALTER TABLE ONLY public.linkio_components
    ADD CONSTRAINT linkio_components_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "linkio_pages_original_url_key"
DETAIL:  Key (original_url)=(https://www.linkio.com/best-link-building-services/) is duplicated.
Command was: ALTER TABLE ONLY public.linkio_pages
    ADD CONSTRAINT linkio_pages_original_url_key UNIQUE (original_url);


pg_restore: error: could not execute query: ERROR:  could not create unique index "linkio_pages_pkey"
DETAIL:  Key (id)=(3d3f8380-ef66-4065-8a06-00eb78f05a8f) is duplicated.
Command was: ALTER TABLE ONLY public.linkio_pages
    ADD CONSTRAINT linkio_pages_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "master_qualification_job_items_pkey"
DETAIL:  Key (id)=(9061ecb4-38cb-4476-a20c-ae7d56033beb) is duplicated.
Command was: ALTER TABLE ONLY public.master_qualification_job_items
    ADD CONSTRAINT master_qualification_job_items_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "master_qualification_jobs_pkey"
DETAIL:  Key (id)=(6d95d008-0594-40ae-b386-645bad5ab9ef) is duplicated.
Command was: ALTER TABLE ONLY public.master_qualification_jobs
    ADD CONSTRAINT master_qualification_jobs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "migration_history_migration_name_key"
DETAIL:  Key (migration_name)=(0042_fix_offering_id_nullable) is duplicated.
Command was: ALTER TABLE ONLY public.migration_history
    ADD CONSTRAINT migration_history_migration_name_key UNIQUE (migration_name);


pg_restore: error: could not execute query: ERROR:  could not create unique index "migration_history_pkey"
DETAIL:  Key (id)=(3) is duplicated.
Command was: ALTER TABLE ONLY public.migration_history
    ADD CONSTRAINT migration_history_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "migrations_name_key"
DETAIL:  Key (name)=(0015_fix_traffic_column_type) is duplicated.
Command was: ALTER TABLE ONLY public.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


pg_restore: error: could not execute query: ERROR:  could not create unique index "migrations_pkey"
DETAIL:  Key (id)=(7) is duplicated.
Command was: ALTER TABLE ONLY public.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_benchmarks_pkey"
DETAIL:  Key (id)=(a37dc1b0-6164-494e-a207-568d69e55086) is duplicated.
Command was: ALTER TABLE ONLY public.order_benchmarks
    ADD CONSTRAINT order_benchmarks_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_groups_pkey"
DETAIL:  Key (id)=(4ead543d-a3fe-48e3-833a-4065b38df22f) is duplicated.
Command was: ALTER TABLE ONLY public.order_groups
    ADD CONSTRAINT order_groups_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_items_pkey"
DETAIL:  Key (id)=(8abde1bc-202b-41d7-83e6-36567efe005a) is duplicated.
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT order_items_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_line_items_pkey"
DETAIL:  Key (id)=(c4ee5283-e91f-4ba9-ab70-76b92766b168) is duplicated.
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "order_share_tokens" are not allowed
Command was: ALTER TABLE ONLY public.order_share_tokens
    ADD CONSTRAINT order_share_tokens_pkey PRIMARY KEY (token);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "order_site_selections" are not allowed
Command was: ALTER TABLE ONLY public.order_site_selections
    ADD CONSTRAINT order_site_selections_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_site_submissions_pkey"
DETAIL:  Key (id)=(7f6ba6e9-2f6f-457b-af24-2e15902a9150) is duplicated.
Command was: ALTER TABLE ONLY public.order_site_submissions
    ADD CONSTRAINT order_site_submissions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "order_status_history_pkey"
DETAIL:  Key (id)=(8e60f331-ace3-4150-ba57-11c9ef7e51f8) is duplicated.
Command was: ALTER TABLE ONLY public.order_status_history
    ADD CONSTRAINT order_status_history_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "orders_pkey"
DETAIL:  Key (id)=(16434354-939d-4e49-a6e1-96bce457e42f) is duplicated.
Command was: ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "orders_share_token_key" already exists
Command was: ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_share_token_key UNIQUE (share_token);


pg_restore: error: could not execute query: ERROR:  could not create unique index "outline_sessions_pkey"
DETAIL:  Key (id)=(72d5ebe2-c70b-4a25-996b-a6def8b1b45e) is duplicated.
Command was: ALTER TABLE ONLY public.outline_sessions
    ADD CONSTRAINT outline_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "password_reset_tokens_pkey"
DETAIL:  Key (id)=(b0ddec28-a484-4b66-b3b0-cd4bdfa74bd3) is duplicated.
Command was: ALTER TABLE ONLY public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "password_reset_tokens_token_key"
DETAIL:  Key (token)=(1c35380fd4aa31cf1bfc8f6c1283f852c86a2bd40cb0298c36eee6b0109ea2bf) is duplicated.
Command was: ALTER TABLE ONLY public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_token_key UNIQUE (token);


pg_restore: error: could not execute query: ERROR:  could not create unique index "payments_pkey"
DETAIL:  Key (id)=(b11bf303-a38d-43e8-802d-e6a54d960efa) is duplicated.
Command was: ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "polish_sections_pkey"
DETAIL:  Key (id)=(6c5d0633-239b-4397-b447-a3dc88df265b) is duplicated.
Command was: ALTER TABLE ONLY public.polish_sections
    ADD CONSTRAINT polish_sections_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "polish_sessions_pkey"
DETAIL:  Key (id)=(6d76ff43-6ee6-4168-99ad-038b93a38294) is duplicated.
Command was: ALTER TABLE ONLY public.polish_sessions
    ADD CONSTRAINT polish_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "pricing_rules_pkey"
DETAIL:  Key (id)=(ad4273ee-83ce-4694-b07b-bdd2c5f61520) is duplicated.
Command was: ALTER TABLE ONLY public.pricing_rules
    ADD CONSTRAINT pricing_rules_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "project_order_associations_order_group_id_project_id_key" already exists
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_order_group_id_project_id_key UNIQUE (order_group_id, project_id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "project_order_associations" are not allowed
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "project_websites" are not allowed
Command was: ALTER TABLE ONLY public.project_websites
    ADD CONSTRAINT project_websites_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "project_websites_project_id_website_id_key" already exists
Command was: ALTER TABLE ONLY public.project_websites
    ADD CONSTRAINT project_websites_project_id_website_id_key UNIQUE (project_id, website_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "publisher_automation_logs_pkey"
DETAIL:  Key (id)=(172fb23f-656a-489c-9073-668317844aea) is duplicated.
Command was: ALTER TABLE ONLY public.publisher_automation_logs
    ADD CONSTRAINT publisher_automation_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_earnings" are not allowed
Command was: ALTER TABLE ONLY public.publisher_earnings
    ADD CONSTRAINT publisher_earnings_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_email_claims" are not allowed
Command was: ALTER TABLE ONLY public.publisher_email_claims
    ADD CONSTRAINT publisher_email_claims_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_email_claims_publisher_id_website_id_key" already exists
Command was: ALTER TABLE ONLY public.publisher_email_claims
    ADD CONSTRAINT publisher_email_claims_publisher_id_website_id_key UNIQUE (publisher_id, website_id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_email_claims_verification_token_key" already exists
Command was: ALTER TABLE ONLY public.publisher_email_claims
    ADD CONSTRAINT publisher_email_claims_verification_token_key UNIQUE (verification_token);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_invoices" are not allowed
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_invoices_publisher_id_invoice_number_key" already exists
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_publisher_id_invoice_number_key UNIQUE (publisher_id, invoice_number);


pg_restore: error: could not execute query: ERROR:  could not create unique index "publisher_offering_relationships_pkey"
DETAIL:  Key (id)=(3629cf78-43da-4e8e-a2f3-88ad85bf681d) is duplicated.
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT publisher_offering_relationships_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "publisher_offering_relationships_unique_offering"
DETAIL:  Key (publisher_id, website_id, offering_id)=(9b649b0d-193d-4e6d-bddf-f172330e5ff1, 68c101de-af44-4ff6-ac31-d9a5a23687a3, d639bbb3-55c2-4c5c-94fb-5c65d9a17568) is duplicated.
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT publisher_offering_relationships_unique_offering UNIQUE (publisher_id, website_id, offering_id);


pg_restore: error: could not execute query: ERROR:  constraint "publisher_offering_relationships_unique_offering" for table "publisher_offering_relationships" does not exist
Command was: COMMENT ON CONSTRAINT publisher_offering_relationships_unique_offering ON public.publisher_offering_relationships IS 'Allows multiple offerings per publisher-website pair, but prevents duplicate offering relationships';


pg_restore: error: could not execute query: ERROR:  could not create unique index "publisher_offerings_pkey"
DETAIL:  Key (id)=(8adff959-dd0a-437f-a9d2-b0c1d0b88965) is duplicated.
Command was: ALTER TABLE ONLY public.publisher_offerings
    ADD CONSTRAINT publisher_offerings_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_order_analytics" are not allowed
Command was: ALTER TABLE ONLY public.publisher_order_analytics
    ADD CONSTRAINT publisher_order_analytics_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_order_analytics_publisher_id_website_id_period_ty_key" already exists
Command was: ALTER TABLE ONLY public.publisher_order_analytics
    ADD CONSTRAINT publisher_order_analytics_publisher_id_website_id_period_ty_key UNIQUE (publisher_id, website_id, period_type, period_date);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_order_notifications" are not allowed
Command was: ALTER TABLE ONLY public.publisher_order_notifications
    ADD CONSTRAINT publisher_order_notifications_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_payment_batches_batch_number_key" already exists
Command was: ALTER TABLE ONLY public.publisher_payment_batches
    ADD CONSTRAINT publisher_payment_batches_batch_number_key UNIQUE (batch_number);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_payment_batches" are not allowed
Command was: ALTER TABLE ONLY public.publisher_payment_batches
    ADD CONSTRAINT publisher_payment_batches_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_payment_profiles" are not allowed
Command was: ALTER TABLE ONLY public.publisher_payment_profiles
    ADD CONSTRAINT publisher_payment_profiles_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_payouts" are not allowed
Command was: ALTER TABLE ONLY public.publisher_payouts
    ADD CONSTRAINT publisher_payouts_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_performance" are not allowed
Command was: ALTER TABLE ONLY public.publisher_performance
    ADD CONSTRAINT publisher_performance_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publisher_performance_publisher_id_website_id_period_start__key" already exists
Command was: ALTER TABLE ONLY public.publisher_performance
    ADD CONSTRAINT publisher_performance_publisher_id_website_id_period_start__key UNIQUE (publisher_id, website_id, period_start, period_end);


pg_restore: error: could not execute query: ERROR:  could not create unique index "publisher_pricing_rules_pkey"
DETAIL:  Key (id)=(935e18db-1ede-4f4b-b4b0-966664055559) is duplicated.
Command was: ALTER TABLE ONLY public.publisher_pricing_rules
    ADD CONSTRAINT publisher_pricing_rules_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "publisher_websites" are not allowed
Command was: ALTER TABLE ONLY public.publisher_websites
    ADD CONSTRAINT publisher_websites_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "publishers_google_id_key" already exists
Command was: ALTER TABLE ONLY public.publishers
    ADD CONSTRAINT publishers_google_id_key UNIQUE (google_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "publishers_pkey"
DETAIL:  Key (id)=(531a0c4e-081e-4f9b-93ce-4b851c6b10cd) is duplicated.
Command was: ALTER TABLE ONLY public.publishers
    ADD CONSTRAINT publishers_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "refunds" are not allowed
Command was: ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "shadow_publisher_websites_pkey"
DETAIL:  Key (id)=(0c6ea067-77b1-4514-b638-5e4a87793316) is duplicated.
Command was: ALTER TABLE ONLY public.shadow_publisher_websites
    ADD CONSTRAINT shadow_publisher_websites_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_customers_pkey"
DETAIL:  Key (id)=(4799d56a-205a-4f4a-bc64-f59d47e5349b) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_customers
    ADD CONSTRAINT stripe_customers_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_customers_stripe_customer_id_key"
DETAIL:  Key (stripe_customer_id)=(cus_SuqqWqATToeNPP) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_customers
    ADD CONSTRAINT stripe_customers_stripe_customer_id_key UNIQUE (stripe_customer_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_payment_intents_idempotency_key_key"
DETAIL:  Key (idempotency_key)=(4c89c946-b008-442a-b8c1-74c57b27e0dd-1755892863198) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_payment_intents
    ADD CONSTRAINT stripe_payment_intents_idempotency_key_key UNIQUE (idempotency_key);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_payment_intents_pkey"
DETAIL:  Key (id)=(8a8eadf1-b48d-4465-86c9-b495e1c6366c) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_payment_intents
    ADD CONSTRAINT stripe_payment_intents_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_payment_intents_stripe_payment_intent_id_key"
DETAIL:  Key (stripe_payment_intent_id)=(pi_3Ruju4LCEW4iTJXC03ZM2E7j) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_payment_intents
    ADD CONSTRAINT stripe_payment_intents_stripe_payment_intent_id_key UNIQUE (stripe_payment_intent_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_webhooks_pkey"
DETAIL:  Key (id)=(1d85a125-fe45-4baa-9a16-d21dfce4a40f) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_webhooks
    ADD CONSTRAINT stripe_webhooks_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "stripe_webhooks_stripe_event_id_key"
DETAIL:  Key (stripe_event_id)=(evt_3RugV5LCEW4iTJXC1H7TlWvC) is duplicated.
Command was: ALTER TABLE ONLY public.stripe_webhooks
    ADD CONSTRAINT stripe_webhooks_stripe_event_id_key UNIQUE (stripe_event_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "target_pages_pkey"
DETAIL:  Key (id)=(b04ea893-2f2c-4b0a-aa80-88f2954000db) is duplicated.
Command was: ALTER TABLE ONLY public.target_pages
    ADD CONSTRAINT target_pages_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "unique_shadow_publisher_website"
DETAIL:  Key (publisher_id, website_id)=(d8c59560-d6c9-4586-8840-4e9ca55e01e7, 825c4aab-0548-4b2b-b501-7c6eb414b9df) is duplicated.
Command was: ALTER TABLE ONLY public.shadow_publisher_websites
    ADD CONSTRAINT unique_shadow_publisher_website UNIQUE (publisher_id, website_id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "user_client_access" are not allowed
Command was: ALTER TABLE ONLY public.user_client_access
    ADD CONSTRAINT user_client_access_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "user_client_access_user_id_client_id_key" already exists
Command was: ALTER TABLE ONLY public.user_client_access
    ADD CONSTRAINT user_client_access_user_id_client_id_key UNIQUE (user_id, client_id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "user_website_access" are not allowed
Command was: ALTER TABLE ONLY public.user_website_access
    ADD CONSTRAINT user_website_access_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "user_website_access_user_id_website_id_key" already exists
Command was: ALTER TABLE ONLY public.user_website_access
    ADD CONSTRAINT user_website_access_user_id_website_id_key UNIQUE (user_id, website_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "users_email_key"
DETAIL:  Key (email)=(miro@outreachlabs.com) is duplicated.
Command was: ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


pg_restore: error: could not execute query: ERROR:  relation "users_google_id_key" already exists
Command was: ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_google_id_key UNIQUE (google_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "users_pkey"
DETAIL:  Key (id)=(bde182d1-f972-4f96-a51c-17b1e8fb1b35) is duplicated.
Command was: ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "v2_agent_sessions_pkey"
DETAIL:  Key (id)=(4a297f8d-4817-4dd7-9fb7-17a48592de66) is duplicated.
Command was: ALTER TABLE ONLY public.v2_agent_sessions
    ADD CONSTRAINT v2_agent_sessions_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "webhook_security_logs_pkey"
DETAIL:  Key (id)=(4) is duplicated.
Command was: ALTER TABLE ONLY public.webhook_security_logs
    ADD CONSTRAINT webhook_security_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "website_contacts_airtable_link_price_id_key" already exists
Command was: ALTER TABLE ONLY public.website_contacts
    ADD CONSTRAINT website_contacts_airtable_link_price_id_key UNIQUE (airtable_link_price_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "website_contacts_pkey"
DETAIL:  Key (id)=(9f30af61-6adc-4d5f-bda2-418696ff7d28) is duplicated.
Command was: ALTER TABLE ONLY public.website_contacts
    ADD CONSTRAINT website_contacts_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "website_contacts_website_id_email_key"
DETAIL:  Key (website_id, email)=(84e09987-192f-4204-bfbe-ae7aed1faa8d, margaret@interview-coach.co.uk) is duplicated.
Command was: ALTER TABLE ONLY public.website_contacts
    ADD CONSTRAINT website_contacts_website_id_email_key UNIQUE (website_id, email);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "website_qualifications" are not allowed
Command was: ALTER TABLE ONLY public.website_qualifications
    ADD CONSTRAINT website_qualifications_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "website_qualifications_website_id_client_id_project_id_key" already exists
Command was: ALTER TABLE ONLY public.website_qualifications
    ADD CONSTRAINT website_qualifications_website_id_client_id_project_id_key UNIQUE (website_id, client_id, project_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "website_sync_logs_pkey"
DETAIL:  Key (id)=(60628be4-0b8a-4cc3-9681-4d78b56ff582) is duplicated.
Command was: ALTER TABLE ONLY public.website_sync_logs
    ADD CONSTRAINT website_sync_logs_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "websites_airtable_id_key"
DETAIL:  Key (airtable_id)=(recK5vGpXK98YT805) is duplicated.
Command was: ALTER TABLE ONLY public.websites
    ADD CONSTRAINT websites_airtable_id_key UNIQUE (airtable_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "websites_domain_key"
DETAIL:  Key (domain)=(naturalbeautywithbaby.com) is duplicated.
Command was: ALTER TABLE ONLY public.websites
    ADD CONSTRAINT websites_domain_key UNIQUE (domain);


pg_restore: error: could not execute query: ERROR:  could not create unique index "websites_pkey"
DETAIL:  Key (id)=(86ad307d-4b50-435c-b3ab-04161f5719e0) is duplicated.
Command was: ALTER TABLE ONLY public.websites
    ADD CONSTRAINT websites_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "workflow_steps" are not allowed
Command was: ALTER TABLE ONLY public.workflow_steps
    ADD CONSTRAINT workflow_steps_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  multiple primary keys for table "workflow_websites" are not allowed
Command was: ALTER TABLE ONLY public.workflow_websites
    ADD CONSTRAINT workflow_websites_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "workflow_websites_workflow_id_website_id_step_added_usage_t_key" already exists
Command was: ALTER TABLE ONLY public.workflow_websites
    ADD CONSTRAINT workflow_websites_workflow_id_website_id_step_added_usage_t_key UNIQUE (workflow_id, website_id, step_added, usage_type);


pg_restore: error: could not execute query: ERROR:  could not create unique index "workflows_pkey"
DETAIL:  Key (id)=(a9489448-9ae1-4ad0-9488-6e80ba83cff7) is duplicated.
Command was: ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_pkey PRIMARY KEY (id);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_checks_qa_session_id_idx" already exists
Command was: CREATE INDEX formatting_qa_checks_qa_session_id_idx ON public.formatting_qa_checks USING btree (qa_session_id);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_checks_status_idx" already exists
Command was: CREATE INDEX formatting_qa_checks_status_idx ON public.formatting_qa_checks USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_checks_workflow_id_idx" already exists
Command was: CREATE INDEX formatting_qa_checks_workflow_id_idx ON public.formatting_qa_checks USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_sessions_status_idx" already exists
Command was: CREATE INDEX formatting_qa_sessions_status_idx ON public.formatting_qa_sessions USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "formatting_qa_sessions_workflow_id_idx" already exists
Command was: CREATE INDEX formatting_qa_sessions_workflow_id_idx ON public.formatting_qa_sessions USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_accounts_auth_method" already exists
Command was: CREATE INDEX idx_accounts_auth_method ON public.accounts USING btree (auth_method);


pg_restore: error: could not execute query: ERROR:  relation "idx_accounts_google_id" already exists
Command was: CREATE INDEX idx_accounts_google_id ON public.accounts USING btree (google_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_accounts_onboarding" already exists
Command was: CREATE INDEX idx_accounts_onboarding ON public.accounts USING btree (onboarding_completed);


pg_restore: error: could not execute query: ERROR:  relation "idx_advertisers_client" already exists
Command was: CREATE INDEX idx_advertisers_client ON public.accounts USING btree (primary_client_id);


pg_restore: error: could not execute query: ERROR:  could not create unique index "idx_advertisers_email"
DETAIL:  Key (email)=(lucifermorningstar03112006@gmail.com) is duplicated.
Command was: CREATE UNIQUE INDEX idx_advertisers_email ON public.accounts USING btree (email);


pg_restore: error: could not execute query: ERROR:  relation "idx_advertisers_status" already exists
Command was: CREATE INDEX idx_advertisers_status ON public.accounts USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_agent_sessions_workflow_id" already exists
Command was: CREATE INDEX idx_agent_sessions_workflow_id ON public.agent_sessions USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_article_sections_workflow_id" already exists
Command was: CREATE INDEX idx_article_sections_workflow_id ON public.article_sections USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_automation_logs_publisher" already exists
Command was: CREATE INDEX idx_automation_logs_publisher ON public.publisher_automation_logs USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_benchmarks_order" already exists
Command was: CREATE INDEX idx_benchmarks_order ON public.order_benchmarks USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_benchmarks_type" already exists
Command was: CREATE INDEX idx_benchmarks_type ON public.order_benchmarks USING btree (benchmark_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_airtable_record_id" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_airtable_record_id ON public.bulk_analysis_domains USING btree (airtable_record_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_client_id" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_client_id ON public.bulk_analysis_domains USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_client_status_workflow" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_client_status_workflow ON public.bulk_analysis_domains USING btree (client_id, qualification_status, has_workflow);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_created_at" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_created_at ON public.bulk_analysis_domains USING btree (created_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_domain" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_domain ON public.bulk_analysis_domains USING btree (domain);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_has_workflow" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_has_workflow ON public.bulk_analysis_domains USING btree (has_workflow);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_qualification_status" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_qualification_status ON public.bulk_analysis_domains USING btree (qualification_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_analysis_domains_status" already exists
Command was: CREATE INDEX idx_bulk_analysis_domains_status ON public.bulk_analysis_domains USING btree (qualification_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_domains_duplicate_of" already exists
Command was: CREATE INDEX idx_bulk_domains_duplicate_of ON public.bulk_analysis_domains USING btree (duplicate_of);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_domains_original_project" already exists
Command was: CREATE INDEX idx_bulk_domains_original_project ON public.bulk_analysis_domains USING btree (original_project_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_domains_project" already exists
Command was: CREATE INDEX idx_bulk_domains_project ON public.bulk_analysis_domains USING btree (project_id) WHERE (project_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_domains_project_status" already exists
Command was: CREATE INDEX idx_bulk_domains_project_status ON public.bulk_analysis_domains USING btree (project_id, qualification_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_domains_resolution" already exists
Command was: CREATE INDEX idx_bulk_domains_resolution ON public.bulk_analysis_domains USING btree (duplicate_resolution);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_normalized_domain" already exists
Command was: CREATE INDEX idx_bulk_normalized_domain ON public.bulk_analysis_domains USING btree (normalized_domain);


pg_restore: error: could not execute query: ERROR:  relation "idx_bulk_projects_client" already exists
Command was: CREATE INDEX idx_bulk_projects_client ON public.bulk_analysis_projects USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_changes_batch" already exists
Command was: CREATE INDEX idx_changes_batch ON public.line_item_changes USING btree (batch_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_changes_line_item" already exists
Command was: CREATE INDEX idx_changes_line_item ON public.line_item_changes USING btree (line_item_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_changes_order" already exists
Command was: CREATE INDEX idx_changes_order ON public.line_item_changes USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_changes_type" already exists
Command was: CREATE INDEX idx_changes_type ON public.line_item_changes USING btree (change_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_client_assignments_user_id" already exists
Command was: CREATE INDEX idx_client_assignments_user_id ON public.client_assignments USING btree (user_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_clients_account_id" already exists
Command was: CREATE INDEX idx_clients_account_id ON public.clients USING btree (account_id) WHERE (account_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_clients_share_token" already exists
Command was: CREATE INDEX idx_clients_share_token ON public.clients USING btree (share_token) WHERE (share_token IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_clients_type" already exists
Command was: CREATE INDEX idx_clients_type ON public.clients USING btree (client_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_commission_config_active" already exists
Command was: CREATE INDEX idx_commission_config_active ON public.commission_configurations USING btree (is_active);


pg_restore: error: could not execute query: ERROR:  relation "idx_commission_config_scope" already exists
Command was: CREATE INDEX idx_commission_config_scope ON public.commission_configurations USING btree (scope_type, scope_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_commission_config_unique_scope" already exists
Command was: CREATE UNIQUE INDEX idx_commission_config_unique_scope ON public.commission_configurations USING btree (scope_type, scope_id) WHERE ((is_active = true) AND (valid_until IS NULL));


pg_restore: error: could not execute query: ERROR:  relation "idx_comparison_benchmark" already exists
Command was: CREATE INDEX idx_comparison_benchmark ON public.benchmark_comparisons USING btree (benchmark_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_comparison_latest" already exists
Command was: CREATE INDEX idx_comparison_latest ON public.benchmark_comparisons USING btree (order_id, compared_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_comparison_order" already exists
Command was: CREATE INDEX idx_comparison_order ON public.benchmark_comparisons USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_cron_jobs_next_run" already exists
Command was: CREATE INDEX idx_cron_jobs_next_run ON public.cron_jobs USING btree (next_run_at) WHERE (enabled = true);


pg_restore: error: could not execute query: ERROR:  relation "idx_dataforseo_logs_client_id" already exists
Command was: CREATE INDEX idx_dataforseo_logs_client_id ON public.dataforseo_api_logs USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_dataforseo_logs_domain_id" already exists
Command was: CREATE INDEX idx_dataforseo_logs_domain_id ON public.dataforseo_api_logs USING btree (domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_dataforseo_logs_requested_at" already exists
Command was: CREATE INDEX idx_dataforseo_logs_requested_at ON public.dataforseo_api_logs USING btree (requested_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_dataforseo_logs_task_id" already exists
Command was: CREATE INDEX idx_dataforseo_logs_task_id ON public.dataforseo_api_logs USING btree (task_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_domain_suggestions_unique" already exists
Command was: CREATE UNIQUE INDEX idx_domain_suggestions_unique ON public.domain_suggestions USING btree (account_id, domain_id) WHERE (account_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_domain_suggestions_unique_email" already exists
Command was: CREATE UNIQUE INDEX idx_domain_suggestions_unique_email ON public.domain_suggestions USING btree (account_email, domain_id) WHERE (account_id IS NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_claims_publisher" already exists
Command was: CREATE INDEX idx_email_claims_publisher ON public.publisher_email_claims USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_claims_status" already exists
Command was: CREATE INDEX idx_email_claims_status ON public.publisher_email_claims USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_claims_token" already exists
Command was: CREATE INDEX idx_email_claims_token ON public.publisher_email_claims USING btree (verification_token);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_claims_website" already exists
Command was: CREATE INDEX idx_email_claims_website ON public.publisher_email_claims USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_created_at" already exists
Command was: CREATE INDEX idx_email_logs_created_at ON public.email_logs USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_email_from" already exists
Command was: CREATE INDEX idx_email_logs_email_from ON public.email_processing_logs USING btree (lower((email_from)::text));


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_recipients" already exists
Command was: CREATE INDEX idx_email_logs_recipients ON public.email_logs USING gin (recipients);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_resend_id" already exists
Command was: CREATE INDEX idx_email_logs_resend_id ON public.email_logs USING btree (resend_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_sent_at" already exists
Command was: CREATE INDEX idx_email_logs_sent_at ON public.email_logs USING btree (sent_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_status" already exists
Command was: CREATE INDEX idx_email_logs_status ON public.email_logs USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_email_logs_type" already exists
Command was: CREATE INDEX idx_email_logs_type ON public.email_logs USING btree (type);


pg_restore: error: could not execute query: ERROR:  relation "idx_guest_post_items_domain_id" already exists
Command was: CREATE INDEX idx_guest_post_items_domain_id ON public.guest_post_items USING btree (domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_guest_post_items_order_id" already exists
Command was: CREATE INDEX idx_guest_post_items_order_id ON public.guest_post_items USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_guest_post_items_status" already exists
Command was: CREATE INDEX idx_guest_post_items_status ON public.guest_post_items USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_guest_post_items_workflow_id" already exists
Command was: CREATE INDEX idx_guest_post_items_workflow_id ON public.guest_post_items USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_invitations_email" already exists
Command was: CREATE INDEX idx_invitations_email ON public.invitations USING btree (email);


pg_restore: error: could not execute query: ERROR:  relation "idx_invitations_expires_at" already exists
Command was: CREATE INDEX idx_invitations_expires_at ON public.invitations USING btree (expires_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_invitations_token" already exists
Command was: CREATE INDEX idx_invitations_token ON public.invitations USING btree (token);


pg_restore: error: could not execute query: ERROR:  relation "idx_invoices_order_id" already exists
Command was: CREATE INDEX idx_invoices_order_id ON public.invoices USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_invoices_payment_id" already exists
Command was: CREATE INDEX idx_invoices_payment_id ON public.invoices USING btree (payment_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_invoices_status" already exists
Command was: CREATE INDEX idx_invoices_status ON public.invoices USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_analysis_domain" already exists
Command was: CREATE INDEX idx_keyword_analysis_domain ON public.keyword_analysis_results USING btree (bulk_analysis_domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_analysis_position" already exists
Command was: CREATE INDEX idx_keyword_analysis_position ON public.keyword_analysis_results USING btree ("position");


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_analysis_results_batch" already exists
Command was: CREATE INDEX idx_keyword_analysis_results_batch ON public.keyword_analysis_results USING btree (analysis_batch_id, created_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_analysis_results_keyword_domain" already exists
Command was: CREATE INDEX idx_keyword_analysis_results_keyword_domain ON public.keyword_analysis_results USING btree (bulk_analysis_domain_id, keyword);


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_search_history_domain" already exists
Command was: CREATE INDEX idx_keyword_search_history_domain ON public.keyword_search_history USING btree (bulk_analysis_domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_keyword_search_history_searched_at" already exists
Command was: CREATE INDEX idx_keyword_search_history_searched_at ON public.keyword_search_history USING btree (searched_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_item_changes_batch_id" already exists
Command was: CREATE INDEX idx_line_item_changes_batch_id ON public.line_item_changes USING btree (batch_id) WHERE (batch_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_item_changes_change_type" already exists
Command was: CREATE INDEX idx_line_item_changes_change_type ON public.line_item_changes USING btree (change_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_item_changes_order_id" already exists
Command was: CREATE INDEX idx_line_item_changes_order_id ON public.line_item_changes USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_client" already exists
Command was: CREATE INDEX idx_line_items_client ON public.order_line_items USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_order" already exists
Command was: CREATE INDEX idx_line_items_order ON public.order_line_items USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_publisher_id" already exists
Command was: CREATE INDEX idx_line_items_publisher_id ON public.order_line_items USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_publisher_offering" already exists
Command was: CREATE INDEX idx_line_items_publisher_offering ON public.order_line_items USING btree (publisher_offering_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_publisher_status" already exists
Command was: CREATE INDEX idx_line_items_publisher_status ON public.order_line_items USING btree (publisher_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_line_items_status" already exists
Command was: CREATE INDEX idx_line_items_status ON public.order_line_items USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_link_orchestration_status" already exists
Command was: CREATE INDEX idx_link_orchestration_status ON public.link_orchestration_sessions USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_link_orchestration_workflow_id" already exists
Command was: CREATE INDEX idx_link_orchestration_workflow_id ON public.link_orchestration_sessions USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_linkio_assets_page_id" already exists
Command was: CREATE INDEX idx_linkio_assets_page_id ON public.linkio_assets USING btree (page_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_linkio_components_page_id" already exists
Command was: CREATE INDEX idx_linkio_components_page_id ON public.linkio_components USING btree (page_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_linkio_pages_priority" already exists
Command was: CREATE INDEX idx_linkio_pages_priority ON public.linkio_pages USING btree (priority);


pg_restore: error: could not execute query: ERROR:  relation "idx_linkio_pages_status" already exists
Command was: CREATE INDEX idx_linkio_pages_status ON public.linkio_pages USING btree (recreation_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_linkio_pages_type" already exists
Command was: CREATE INDEX idx_linkio_pages_type ON public.linkio_pages USING btree (page_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_migration_history_executed" already exists
Command was: CREATE INDEX idx_migration_history_executed ON public.migration_history USING btree (executed_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_migration_history_name" already exists
Command was: CREATE INDEX idx_migration_history_name ON public.migration_history USING btree (migration_name);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_benchmarks_latest" already exists
Command was: CREATE INDEX idx_order_benchmarks_latest ON public.order_benchmarks USING btree (order_id, is_latest) WHERE (is_latest = true);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_benchmarks_order_id" already exists
Command was: CREATE INDEX idx_order_benchmarks_order_id ON public.order_benchmarks USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_groups_analysis" already exists
Command was: CREATE INDEX idx_order_groups_analysis ON public.order_groups USING btree (bulk_analysis_project_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_groups_client" already exists
Command was: CREATE INDEX idx_order_groups_client ON public.order_groups USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_groups_order" already exists
Command was: CREATE INDEX idx_order_groups_order ON public.order_groups USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_items_target_page_id" already exists
Command was: CREATE INDEX idx_order_items_target_page_id ON public.guest_post_items USING btree (target_page_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_line_items_publisher_id" already exists
Command was: CREATE INDEX idx_order_line_items_publisher_id ON public.order_line_items USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_line_items_publisher_offering" already exists
Command was: CREATE INDEX idx_order_line_items_publisher_offering ON public.order_line_items USING btree (publisher_offering_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_order_line_items_publisher_status" already exists
Command was: CREATE INDEX idx_order_line_items_publisher_status ON public.order_line_items USING btree (publisher_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_advertiser" already exists
Command was: CREATE INDEX idx_orders_advertiser ON public.orders USING btree (account_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_advertiser_id" already exists
Command was: CREATE INDEX idx_orders_advertiser_id ON public.orders USING btree (account_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_client_notified_at" already exists
Command was: CREATE INDEX idx_orders_client_notified_at ON public.orders USING btree (client_notified_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_created_by" already exists
Command was: CREATE INDEX idx_orders_created_by ON public.orders USING btree (created_by);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_delivered_at" already exists
Command was: CREATE INDEX idx_orders_delivered_at ON public.orders USING btree (delivered_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_order_type" already exists
Command was: CREATE INDEX idx_orders_order_type ON public.orders USING btree (order_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_ready_for_delivery" already exists
Command was: CREATE INDEX idx_orders_ready_for_delivery ON public.orders USING btree (ready_for_delivery);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_share_token" already exists
Command was: CREATE INDEX idx_orders_share_token ON public.orders USING btree (share_token);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_status" already exists
Command was: CREATE INDEX idx_orders_status ON public.orders USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_orders_workflow_completion" already exists
Command was: CREATE INDEX idx_orders_workflow_completion ON public.orders USING btree (workflow_completion_percentage);


pg_restore: error: could not execute query: ERROR:  relation "idx_outline_sessions_active" already exists
Command was: CREATE INDEX idx_outline_sessions_active ON public.outline_sessions USING btree (workflow_id, is_active) WHERE (is_active = true);


pg_restore: error: could not execute query: ERROR:  relation "idx_outline_sessions_response_id" already exists
Command was: CREATE INDEX idx_outline_sessions_response_id ON public.outline_sessions USING btree (background_response_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_outline_sessions_status" already exists
Command was: CREATE INDEX idx_outline_sessions_status ON public.outline_sessions USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_outline_sessions_version" already exists
Command was: CREATE INDEX idx_outline_sessions_version ON public.outline_sessions USING btree (workflow_id, version DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_outline_sessions_workflow_id" already exists
Command was: CREATE INDEX idx_outline_sessions_workflow_id ON public.outline_sessions USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_password_reset_tokens_expires_at" already exists
Command was: CREATE INDEX idx_password_reset_tokens_expires_at ON public.password_reset_tokens USING btree (expires_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_password_reset_tokens_token" already exists
Command was: CREATE INDEX idx_password_reset_tokens_token ON public.password_reset_tokens USING btree (token);


pg_restore: error: could not execute query: ERROR:  relation "idx_password_reset_tokens_user_id" already exists
Command was: CREATE INDEX idx_password_reset_tokens_user_id ON public.password_reset_tokens USING btree (user_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payment_batches_created" already exists
Command was: CREATE INDEX idx_payment_batches_created ON public.publisher_payment_batches USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_payment_batches_publisher" already exists
Command was: CREATE INDEX idx_payment_batches_publisher ON public.publisher_payment_batches USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payment_batches_status" already exists
Command was: CREATE INDEX idx_payment_batches_status ON public.publisher_payment_batches USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_account" already exists
Command was: CREATE INDEX idx_payments_account ON public.payments USING btree (account_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_account_id" already exists
Command was: CREATE INDEX idx_payments_account_id ON public.payments USING btree (account_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_order" already exists
Command was: CREATE INDEX idx_payments_order ON public.payments USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_order_id" already exists
Command was: CREATE INDEX idx_payments_order_id ON public.payments USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_status" already exists
Command was: CREATE INDEX idx_payments_status ON public.payments USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_payments_stripe_intent" already exists
Command was: CREATE INDEX idx_payments_stripe_intent ON public.payments USING btree (stripe_payment_intent_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payouts_publisher" already exists
Command was: CREATE INDEX idx_payouts_publisher ON public.publisher_payouts USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_payouts_status" already exists
Command was: CREATE INDEX idx_payouts_status ON public.publisher_payouts USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_performance_period" already exists
Command was: CREATE INDEX idx_performance_period ON public.publisher_performance USING btree (period_start, period_end);


pg_restore: error: could not execute query: ERROR:  relation "idx_performance_publisher" already exists
Command was: CREATE INDEX idx_performance_publisher ON public.publisher_performance USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_performance_website" already exists
Command was: CREATE INDEX idx_performance_website ON public.publisher_performance USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_pricing_rules_active" already exists
Command was: CREATE INDEX idx_pricing_rules_active ON public.publisher_pricing_rules USING btree (is_active);


pg_restore: error: could not execute query: ERROR:  relation "idx_pricing_rules_client" already exists
Command was: CREATE INDEX idx_pricing_rules_client ON public.pricing_rules USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_pricing_rules_offering" already exists
Command was: CREATE INDEX idx_pricing_rules_offering ON public.publisher_pricing_rules USING btree (publisher_offering_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_pricing_rules_quantity" already exists
Command was: CREATE INDEX idx_pricing_rules_quantity ON public.pricing_rules USING btree (min_quantity, max_quantity);


pg_restore: error: could not execute query: ERROR:  relation "idx_proj_order_assoc_order" already exists
Command was: CREATE INDEX idx_proj_order_assoc_order ON public.project_order_associations USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_proj_order_assoc_order_group" already exists
Command was: CREATE INDEX idx_proj_order_assoc_order_group ON public.project_order_associations USING btree (order_group_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_proj_order_assoc_project" already exists
Command was: CREATE INDEX idx_proj_order_assoc_project ON public.project_order_associations USING btree (project_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_project_websites_added_by" already exists
Command was: CREATE INDEX idx_project_websites_added_by ON public.project_websites USING btree (added_by);


pg_restore: error: could not execute query: ERROR:  relation "idx_project_websites_project_id" already exists
Command was: CREATE INDEX idx_project_websites_project_id ON public.project_websites USING btree (project_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_project_websites_status" already exists
Command was: CREATE INDEX idx_project_websites_status ON public.project_websites USING btree (analysis_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_project_websites_website_id" already exists
Command was: CREATE INDEX idx_project_websites_website_id ON public.project_websites USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_analytics_period" already exists
Command was: CREATE INDEX idx_publisher_analytics_period ON public.publisher_order_analytics USING btree (period_type, period_date);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_analytics_publisher" already exists
Command was: CREATE INDEX idx_publisher_analytics_publisher ON public.publisher_order_analytics USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_analytics_website" already exists
Command was: CREATE INDEX idx_publisher_analytics_website ON public.publisher_order_analytics USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_created" already exists
Command was: CREATE INDEX idx_publisher_earnings_created ON public.publisher_earnings USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_created_at" already exists
Command was: CREATE INDEX idx_publisher_earnings_created_at ON public.publisher_earnings USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_payment_batch" already exists
Command was: CREATE INDEX idx_publisher_earnings_payment_batch ON public.publisher_earnings USING btree (payment_batch_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_publisher" already exists
Command was: CREATE INDEX idx_publisher_earnings_publisher ON public.publisher_earnings USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_publisher_id" already exists
Command was: CREATE INDEX idx_publisher_earnings_publisher_id ON public.publisher_earnings USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_earnings_status" already exists
Command was: CREATE INDEX idx_publisher_earnings_status ON public.publisher_earnings USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_invoices_created_at" already exists
Command was: CREATE INDEX idx_publisher_invoices_created_at ON public.publisher_invoices USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_invoices_publisher_id" already exists
Command was: CREATE INDEX idx_publisher_invoices_publisher_id ON public.publisher_invoices USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_invoices_status" already exists
Command was: CREATE INDEX idx_publisher_invoices_status ON public.publisher_invoices USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_notifications_line_item" already exists
Command was: CREATE INDEX idx_publisher_notifications_line_item ON public.publisher_order_notifications USING btree (order_line_item_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_notifications_publisher" already exists
Command was: CREATE INDEX idx_publisher_notifications_publisher ON public.publisher_order_notifications USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_notifications_status" already exists
Command was: CREATE INDEX idx_publisher_notifications_status ON public.publisher_order_notifications USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_notifications_type" already exists
Command was: CREATE INDEX idx_publisher_notifications_type ON public.publisher_order_notifications USING btree (notification_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_offering_rel_priority" already exists
Command was: CREATE INDEX idx_publisher_offering_rel_priority ON public.publisher_offering_relationships USING btree (website_id, priority_rank);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_offering_rel_verification" already exists
Command was: CREATE INDEX idx_publisher_offering_rel_verification ON public.publisher_offering_relationships USING btree (verification_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_offerings_active" already exists
Command was: CREATE INDEX idx_publisher_offerings_active ON public.publisher_offerings USING btree (is_active);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_offerings_publisher_id" already exists
Command was: CREATE INDEX idx_publisher_offerings_publisher_id ON public.publisher_offerings USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_offerings_type" already exists
Command was: CREATE INDEX idx_publisher_offerings_type ON public.publisher_offerings USING btree (offering_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_payment_profiles_publisher_id" already exists
Command was: CREATE INDEX idx_publisher_payment_profiles_publisher_id ON public.publisher_payment_profiles USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_relationships_offering" already exists
Command was: CREATE INDEX idx_publisher_relationships_offering ON public.publisher_offering_relationships USING btree (offering_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_relationships_publisher" already exists
Command was: CREATE INDEX idx_publisher_relationships_publisher ON public.publisher_offering_relationships USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_relationships_website" already exists
Command was: CREATE INDEX idx_publisher_relationships_website ON public.publisher_offering_relationships USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_website_unique" already exists
Command was: CREATE UNIQUE INDEX idx_publisher_website_unique ON public.publisher_websites USING btree (publisher_id, website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_websites_publisher" already exists
Command was: CREATE INDEX idx_publisher_websites_publisher ON public.publisher_websites USING btree (publisher_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publisher_websites_website" already exists
Command was: CREATE INDEX idx_publisher_websites_website ON public.publisher_websites USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_account_status" already exists
Command was: CREATE INDEX idx_publishers_account_status ON public.publishers USING btree (account_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_auth_method" already exists
Command was: CREATE INDEX idx_publishers_auth_method ON public.publishers USING btree (auth_method);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_claimed_at" already exists
Command was: CREATE INDEX idx_publishers_claimed_at ON public.publishers USING btree (claimed_at) WHERE (claimed_at IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_confidence_score" already exists
Command was: CREATE INDEX idx_publishers_confidence_score ON public.publishers USING btree (confidence_score) WHERE (confidence_score IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  could not create unique index "idx_publishers_email_active"
DETAIL:  Key (lower(email::text))=(justjay@thehypemagazine.com) is duplicated.
Command was: CREATE UNIQUE INDEX idx_publishers_email_active ON public.publishers USING btree (lower((email)::text)) WHERE ((account_status)::text <> ALL ((ARRAY['unclaimed'::character varying, 'shadow'::character varying])::text[]));


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_google_id" already exists
Command was: CREATE INDEX idx_publishers_google_id ON public.publishers USING btree (google_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_invitation_token" already exists
Command was: CREATE INDEX idx_publishers_invitation_token ON public.publishers USING btree (invitation_token) WHERE (invitation_token IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_source" already exists
Command was: CREATE INDEX idx_publishers_source ON public.publishers USING btree (source);


pg_restore: error: could not execute query: ERROR:  relation "idx_publishers_status" already exists
Command was: CREATE INDEX idx_publishers_status ON public.publishers USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_refunds_order" already exists
Command was: CREATE INDEX idx_refunds_order ON public.refunds USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_refunds_payment" already exists
Command was: CREATE INDEX idx_refunds_payment ON public.refunds USING btree (payment_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_refunds_status" already exists
Command was: CREATE INDEX idx_refunds_status ON public.refunds USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_refunds_stripe_id" already exists
Command was: CREATE UNIQUE INDEX idx_refunds_stripe_id ON public.refunds USING btree (stripe_refund_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_review_queue_status" already exists
Command was: CREATE INDEX idx_review_queue_status ON public.email_review_queue USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_selections_domain" already exists
Command was: CREATE INDEX idx_selections_domain ON public.order_site_selections USING btree (domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_selections_group" already exists
Command was: CREATE INDEX idx_selections_group ON public.order_site_selections USING btree (order_group_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_selections_status" already exists
Command was: CREATE INDEX idx_selections_status ON public.order_site_selections USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_customers_account" already exists
Command was: CREATE INDEX idx_stripe_customers_account ON public.stripe_customers USING btree (account_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_customers_email" already exists
Command was: CREATE INDEX idx_stripe_customers_email ON public.stripe_customers USING btree (email);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_customers_stripe_id" already exists
Command was: CREATE INDEX idx_stripe_customers_stripe_id ON public.stripe_customers USING btree (stripe_customer_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_payment_intents_customer" already exists
Command was: CREATE INDEX idx_stripe_payment_intents_customer ON public.stripe_payment_intents USING btree (stripe_customer_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_payment_intents_order_id" already exists
Command was: CREATE INDEX idx_stripe_payment_intents_order_id ON public.stripe_payment_intents USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_payment_intents_status" already exists
Command was: CREATE INDEX idx_stripe_payment_intents_status ON public.stripe_payment_intents USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_payment_intents_stripe_id" already exists
Command was: CREATE INDEX idx_stripe_payment_intents_stripe_id ON public.stripe_payment_intents USING btree (stripe_payment_intent_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_webhooks_created" already exists
Command was: CREATE INDEX idx_stripe_webhooks_created ON public.stripe_webhooks USING btree (created_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_webhooks_event_id" already exists
Command was: CREATE INDEX idx_stripe_webhooks_event_id ON public.stripe_webhooks USING btree (stripe_event_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_webhooks_order" already exists
Command was: CREATE INDEX idx_stripe_webhooks_order ON public.stripe_webhooks USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_webhooks_status" already exists
Command was: CREATE INDEX idx_stripe_webhooks_status ON public.stripe_webhooks USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_stripe_webhooks_type" already exists
Command was: CREATE INDEX idx_stripe_webhooks_type ON public.stripe_webhooks USING btree (event_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_submissions_domain" already exists
Command was: CREATE INDEX idx_submissions_domain ON public.order_site_submissions USING btree (domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_submissions_inclusion_status" already exists
Command was: CREATE INDEX idx_submissions_inclusion_status ON public.order_site_submissions USING btree (inclusion_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_submissions_order_group" already exists
Command was: CREATE INDEX idx_submissions_order_group ON public.order_site_submissions USING btree (order_group_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_submissions_pool" already exists
Command was: CREATE INDEX idx_submissions_pool ON public.order_site_submissions USING btree (order_group_id, selection_pool, pool_rank);


pg_restore: error: could not execute query: ERROR:  relation "idx_submissions_status" already exists
Command was: CREATE INDEX idx_submissions_status ON public.order_site_submissions USING btree (submission_status);


pg_restore: error: could not execute query: ERROR:  relation "idx_suggestions_advertiser" already exists
Command was: CREATE INDEX idx_suggestions_advertiser ON public.domain_suggestions USING btree (account_id, account_email);


pg_restore: error: could not execute query: ERROR:  relation "idx_suggestions_domain" already exists
Command was: CREATE INDEX idx_suggestions_domain ON public.domain_suggestions USING btree (domain_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_suggestions_status" already exists
Command was: CREATE INDEX idx_suggestions_status ON public.domain_suggestions USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_sync_logs_started" already exists
Command was: CREATE INDEX idx_sync_logs_started ON public.website_sync_logs USING btree (started_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_sync_logs_type" already exists
Command was: CREATE INDEX idx_sync_logs_type ON public.website_sync_logs USING btree (sync_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_sync_logs_website" already exists
Command was: CREATE INDEX idx_sync_logs_website ON public.website_sync_logs USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_target_pages_client_id" already exists
Command was: CREATE INDEX idx_target_pages_client_id ON public.target_pages USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_target_pages_client_normalized_url" already exists
Command was: CREATE INDEX idx_target_pages_client_normalized_url ON public.target_pages USING btree (client_id, normalized_url);


pg_restore: error: could not execute query: ERROR:  relation "idx_target_pages_normalized_url" already exists
Command was: CREATE INDEX idx_target_pages_normalized_url ON public.target_pages USING btree (normalized_url);


pg_restore: error: could not execute query: ERROR:  relation "idx_user_client_access_client_id" already exists
Command was: CREATE INDEX idx_user_client_access_client_id ON public.user_client_access USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_user_client_access_user_id" already exists
Command was: CREATE INDEX idx_user_client_access_user_id ON public.user_client_access USING btree (user_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_user_website_access_user_id" already exists
Command was: CREATE INDEX idx_user_website_access_user_id ON public.user_website_access USING btree (user_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_user_website_access_website_id" already exists
Command was: CREATE INDEX idx_user_website_access_website_id ON public.user_website_access USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_users_auth_method" already exists
Command was: CREATE INDEX idx_users_auth_method ON public.users USING btree (auth_method);


pg_restore: error: could not execute query: ERROR:  relation "idx_users_google_id" already exists
Command was: CREATE INDEX idx_users_google_id ON public.users USING btree (google_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_users_user_type" already exists
Command was: CREATE INDEX idx_users_user_type ON public.users USING btree (user_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_v2_agent_sessions_status" already exists
Command was: CREATE INDEX idx_v2_agent_sessions_status ON public.v2_agent_sessions USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_v2_agent_sessions_workflow_id" already exists
Command was: CREATE INDEX idx_v2_agent_sessions_workflow_id ON public.v2_agent_sessions USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_v2_agent_sessions_workflow_version" already exists
Command was: CREATE INDEX idx_v2_agent_sessions_workflow_version ON public.v2_agent_sessions USING btree (workflow_id, version);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_events_processed" already exists
Command was: CREATE INDEX idx_webhook_events_processed ON public.airtable_webhook_events USING btree (processed, received_at);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_events_record" already exists
Command was: CREATE INDEX idx_webhook_events_record ON public.airtable_webhook_events USING btree (record_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_security_logs_allowed" already exists
Command was: CREATE INDEX idx_webhook_security_logs_allowed ON public.webhook_security_logs USING btree (allowed);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_security_logs_created_at" already exists
Command was: CREATE INDEX idx_webhook_security_logs_created_at ON public.webhook_security_logs USING btree (created_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_security_logs_ip_address" already exists
Command was: CREATE INDEX idx_webhook_security_logs_ip_address ON public.webhook_security_logs USING btree (ip_address);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_security_logs_rate_limit" already exists
Command was: CREATE INDEX idx_webhook_security_logs_rate_limit ON public.webhook_security_logs USING btree (rate_limit_key, created_at DESC);


pg_restore: error: could not execute query: ERROR:  relation "idx_webhook_security_logs_webhook_id" already exists
Command was: CREATE INDEX idx_webhook_security_logs_webhook_id ON public.webhook_security_logs USING btree (webhook_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_website_contacts_website_primary" already exists
Command was: CREATE INDEX idx_website_contacts_website_primary ON public.website_contacts USING btree (website_id, is_primary);


pg_restore: error: could not execute query: ERROR:  relation "idx_website_qualifications_client" already exists
Command was: CREATE INDEX idx_website_qualifications_client ON public.website_qualifications USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_website_qualifications_project" already exists
Command was: CREATE INDEX idx_website_qualifications_project ON public.website_qualifications USING btree (project_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_added_by_publisher" already exists
Command was: CREATE INDEX idx_websites_added_by_publisher ON public.websites USING btree (added_by_publisher_id) WHERE (added_by_publisher_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_added_by_user" already exists
Command was: CREATE INDEX idx_websites_added_by_user ON public.websites USING btree (added_by_user_id) WHERE (added_by_user_id IS NOT NULL);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_domain" already exists
Command was: CREATE INDEX idx_websites_domain ON public.websites USING btree (domain);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_domain_rating" already exists
Command was: CREATE INDEX idx_websites_domain_rating ON public.websites USING btree (domain_rating);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_niche" already exists
Command was: CREATE INDEX idx_websites_niche ON public.websites USING gin (niche);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_normalized_domain" already exists
Command was: CREATE INDEX idx_websites_normalized_domain ON public.websites USING btree (normalized_domain);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_source" already exists
Command was: CREATE INDEX idx_websites_source ON public.websites USING btree (source);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_status" already exists
Command was: CREATE INDEX idx_websites_status ON public.websites USING btree (status);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_total_traffic" already exists
Command was: CREATE INDEX idx_websites_total_traffic ON public.websites USING btree (total_traffic);


pg_restore: error: could not execute query: ERROR:  relation "idx_websites_website_type" already exists
Command was: CREATE INDEX idx_websites_website_type ON public.websites USING gin (website_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflow_steps_workflow_id" already exists
Command was: CREATE INDEX idx_workflow_steps_workflow_id ON public.workflow_steps USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflow_websites_usage_type" already exists
Command was: CREATE INDEX idx_workflow_websites_usage_type ON public.workflow_websites USING btree (usage_type);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflow_websites_website_id" already exists
Command was: CREATE INDEX idx_workflow_websites_website_id ON public.workflow_websites USING btree (website_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflow_websites_workflow_id" already exists
Command was: CREATE INDEX idx_workflow_websites_workflow_id ON public.workflow_websites USING btree (workflow_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflows_assigned_user_id" already exists
Command was: CREATE INDEX idx_workflows_assigned_user_id ON public.workflows USING btree (assigned_user_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflows_completion_percentage" already exists
Command was: CREATE INDEX idx_workflows_completion_percentage ON public.workflows USING btree (completion_percentage);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflows_is_completed" already exists
Command was: CREATE INDEX idx_workflows_is_completed ON public.workflows USING btree (is_completed);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflows_order_item" already exists
Command was: CREATE INDEX idx_workflows_order_item ON public.workflows USING btree (order_item_id);


pg_restore: error: could not execute query: ERROR:  relation "idx_workflows_user_id" already exists
Command was: CREATE INDEX idx_workflows_user_id ON public.workflows USING btree (user_id);


pg_restore: error: could not execute query: ERROR:  relation "line_items_assigned_domain_idx" already exists
Command was: CREATE INDEX line_items_assigned_domain_idx ON public.order_line_items USING btree (assigned_domain_id);


pg_restore: error: could not execute query: ERROR:  relation "line_items_client_id_idx" already exists
Command was: CREATE INDEX line_items_client_id_idx ON public.order_line_items USING btree (client_id);


pg_restore: error: could not execute query: ERROR:  relation "line_items_order_id_idx" already exists
Command was: CREATE INDEX line_items_order_id_idx ON public.order_line_items USING btree (order_id);


pg_restore: error: could not execute query: ERROR:  relation "line_items_status_idx" already exists
Command was: CREATE INDEX line_items_status_idx ON public.order_line_items USING btree (status);


pg_restore: error: could not execute query: ERROR:  could not create unique index "uk_bulk_analysis_domains_client_domain_project"
DETAIL:  Key (client_id, domain, project_id)=(c4e987f4-0712-4e43-8b57-16a2c45e19b3, quicksilvertranslate.com, b1cf2471-3851-4b7f-8608-2cc317cc9f4a) is duplicated.
Command was: CREATE UNIQUE INDEX uk_bulk_analysis_domains_client_domain_project ON public.bulk_analysis_domains USING btree (client_id, domain, project_id);


pg_restore: error: could not execute query: ERROR:  column "o.account_id" must appear in the GROUP BY clause or be used in an aggregate function
LINE 3:     o.account_id,
            ^
Command was: CREATE OR REPLACE VIEW public.order_summary AS
 SELECT o.id,
    o.account_id,
    o.state,
    o.status,
    o.total_retail,
    count(DISTINCT og.id) AS client_count,
    sum(og.link_count) AS total_links,
    count(DISTINCT oss.id) FILTER (WHERE ((oss.status)::text = 'approved'::text)) AS approved_sites,
    o.created_at,
    o.updated_at
   FROM ((public.orders o
     LEFT JOIN public.order_groups og ON ((og.order_id = o.id)))
     LEFT JOIN public.order_site_selections oss ON ((oss.order_group_id = og.id)))
  GROUP BY o.id;


pg_restore: error: could not execute query: ERROR:  trigger "normalize_bulk_domain_trigger" for relation "bulk_analysis_domains" already exists
Command was: CREATE TRIGGER normalize_bulk_domain_trigger BEFORE INSERT OR UPDATE OF domain ON public.bulk_analysis_domains FOR EACH ROW EXECUTE FUNCTION public.trigger_normalize_domain();


pg_restore: error: could not execute query: ERROR:  trigger "normalize_website_domain_trigger" for relation "websites" already exists
Command was: CREATE TRIGGER normalize_website_domain_trigger BEFORE INSERT OR UPDATE OF domain ON public.websites FOR EACH ROW EXECUTE FUNCTION public.trigger_normalize_domain();


pg_restore: error: could not execute query: ERROR:  trigger "publisher_status_change_trigger" for relation "publishers" already exists
Command was: CREATE TRIGGER publisher_status_change_trigger AFTER UPDATE ON public.publishers FOR EACH ROW EXECUTE FUNCTION public.log_publisher_status_change();


pg_restore: error: could not execute query: ERROR:  trigger "trigger_create_publisher_earning" for relation "order_line_items" already exists
Command was: CREATE TRIGGER trigger_create_publisher_earning AFTER UPDATE ON public.order_line_items FOR EACH ROW EXECUTE FUNCTION public.create_publisher_earning_on_completion();


pg_restore: error: could not execute query: ERROR:  trigger "update_airtable_sync_config_updated_at" for relation "airtable_sync_config" already exists
Command was: CREATE TRIGGER update_airtable_sync_config_updated_at BEFORE UPDATE ON public.airtable_sync_config FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_email_logs_updated_at" for relation "email_logs" already exists
Command was: CREATE TRIGGER update_email_logs_updated_at BEFORE UPDATE ON public.email_logs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_invitations_updated_at" for relation "invitations" already exists
Command was: CREATE TRIGGER update_invitations_updated_at BEFORE UPDATE ON public.invitations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_performance_timestamp" for relation "publisher_performance" already exists
Command was: CREATE TRIGGER update_performance_timestamp BEFORE UPDATE ON public.publisher_performance FOR EACH ROW EXECUTE FUNCTION public.update_publisher_offerings_updated_at();


pg_restore: error: could not execute query: ERROR:  trigger "update_pricing_rules_timestamp" for relation "publisher_pricing_rules" already exists
Command was: CREATE TRIGGER update_pricing_rules_timestamp BEFORE UPDATE ON public.publisher_pricing_rules FOR EACH ROW EXECUTE FUNCTION public.update_publisher_offerings_updated_at();


pg_restore: error: could not execute query: ERROR:  trigger "update_project_stats_on_delete_trigger" for relation "bulk_analysis_domains" already exists
Command was: CREATE TRIGGER update_project_stats_on_delete_trigger AFTER DELETE ON public.bulk_analysis_domains FOR EACH ROW EXECUTE FUNCTION public.update_project_stats_on_delete();


pg_restore: error: could not execute query: ERROR:  trigger "update_project_stats_trigger" for relation "bulk_analysis_domains" already exists
Command was: CREATE TRIGGER update_project_stats_trigger AFTER INSERT OR UPDATE ON public.bulk_analysis_domains FOR EACH ROW EXECUTE FUNCTION public.update_project_stats();


pg_restore: error: could not execute query: ERROR:  trigger "update_project_websites_updated_at" for relation "project_websites" already exists
Command was: CREATE TRIGGER update_project_websites_updated_at BEFORE UPDATE ON public.project_websites FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_publisher_offerings_timestamp" for relation "publisher_offerings" already exists
Command was: CREATE TRIGGER update_publisher_offerings_timestamp BEFORE UPDATE ON public.publisher_offerings FOR EACH ROW EXECUTE FUNCTION public.update_publisher_offerings_updated_at();


pg_restore: error: could not execute query: ERROR:  trigger "update_publisher_relationships_timestamp" for relation "publisher_offering_relationships" already exists
Command was: CREATE TRIGGER update_publisher_relationships_timestamp BEFORE UPDATE ON public.publisher_offering_relationships FOR EACH ROW EXECUTE FUNCTION public.update_publisher_offerings_updated_at();


pg_restore: error: could not execute query: ERROR:  trigger "update_website_contacts_updated_at" for relation "website_contacts" already exists
Command was: CREATE TRIGGER update_website_contacts_updated_at BEFORE UPDATE ON public.website_contacts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_website_qualifications_updated_at" for relation "website_qualifications" already exists
Command was: CREATE TRIGGER update_website_qualifications_updated_at BEFORE UPDATE ON public.website_qualifications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  trigger "update_websites_updated_at" for relation "websites" already exists
Command was: CREATE TRIGGER update_websites_updated_at BEFORE UPDATE ON public.websites FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.account_order_access
    ADD CONSTRAINT advertiser_order_access_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.account_order_access
    ADD CONSTRAINT advertiser_order_access_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.account_order_access
    ADD CONSTRAINT advertiser_order_access_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT advertisers_primary_client_id_fkey FOREIGN KEY (primary_client_id) REFERENCES public.clients(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.agent_sessions
    ADD CONSTRAINT agent_sessions_workflow_id_workflows_id_fk FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.article_sections
    ADD CONSTRAINT article_sections_workflow_id_workflows_id_fk FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "audit_sessions"
Command was: ALTER TABLE ONLY public.audit_sections
    ADD CONSTRAINT audit_sections_audit_session_id_fkey FOREIGN KEY (audit_session_id) REFERENCES public.audit_sessions(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.audit_sections
    ADD CONSTRAINT audit_sections_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.audit_sessions
    ADD CONSTRAINT audit_sessions_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_benchmarks"
Command was: ALTER TABLE ONLY public.benchmark_comparisons
    ADD CONSTRAINT benchmark_comparisons_benchmark_id_fkey FOREIGN KEY (benchmark_id) REFERENCES public.order_benchmarks(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.benchmark_comparisons
    ADD CONSTRAINT benchmark_comparisons_compared_by_fkey FOREIGN KEY (compared_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.benchmark_comparisons
    ADD CONSTRAINT benchmark_comparisons_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_checked_by_fkey FOREIGN KEY (checked_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_duplicate_of_fkey FOREIGN KEY (duplicate_of) REFERENCES public.bulk_analysis_domains(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_duplicate_resolved_by_fkey FOREIGN KEY (duplicate_resolved_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_human_verified_by_fkey FOREIGN KEY (human_verified_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_manually_qualified_by_fkey FOREIGN KEY (manually_qualified_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_original_project_id_fkey FOREIGN KEY (original_project_id) REFERENCES public.bulk_analysis_projects(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.bulk_analysis_domains
    ADD CONSTRAINT bulk_analysis_domains_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.bulk_analysis_projects(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.bulk_analysis_projects
    ADD CONSTRAINT bulk_analysis_projects_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_analysis_projects
    ADD CONSTRAINT bulk_analysis_projects_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.bulk_dataforseo_job_items
    ADD CONSTRAINT bulk_dataforseo_job_items_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_dataforseo_jobs"
Command was: ALTER TABLE ONLY public.bulk_dataforseo_job_items
    ADD CONSTRAINT bulk_dataforseo_job_items_job_id_fkey FOREIGN KEY (job_id) REFERENCES public.bulk_dataforseo_jobs(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.bulk_dataforseo_jobs
    ADD CONSTRAINT bulk_dataforseo_jobs_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.bulk_dataforseo_jobs
    ADD CONSTRAINT bulk_dataforseo_jobs_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.client_assignments
    ADD CONSTRAINT client_assignments_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.client_assignments
    ADD CONSTRAINT client_assignments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "accounts"
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_archived_by_fkey FOREIGN KEY (archived_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "invitations"
Command was: ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_invitation_id_fkey FOREIGN KEY (invitation_id) REFERENCES public.invitations(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.commission_configurations
    ADD CONSTRAINT commission_configurations_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.dataforseo_api_logs
    ADD CONSTRAINT dataforseo_api_logs_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.dataforseo_api_logs
    ADD CONSTRAINT dataforseo_api_logs_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.dataforseo_api_logs
    ADD CONSTRAINT dataforseo_api_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.email_logs
    ADD CONSTRAINT email_logs_sent_by_fkey FOREIGN KEY (sent_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "email_processing_logs"
Command was: ALTER TABLE ONLY public.email_processing_logs
    ADD CONSTRAINT email_processing_logs_original_outreach_id_fkey FOREIGN KEY (original_outreach_id) REFERENCES public.email_processing_logs(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.email_review_queue
    ADD CONSTRAINT email_review_queue_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "email_processing_logs"
Command was: ALTER TABLE ONLY public.email_review_queue
    ADD CONSTRAINT email_review_queue_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.email_processing_logs(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.email_review_queue
    ADD CONSTRAINT email_review_queue_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.email_review_queue
    ADD CONSTRAINT email_review_queue_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_groups"
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT fk_order_items_group FOREIGN KEY (order_group_id) REFERENCES public.order_groups(id);


pg_restore: error: could not execute query: ERROR:  constraint "fk_order_items_selection" for relation "guest_post_items" already exists
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT fk_order_items_selection FOREIGN KEY (site_selection_id) REFERENCES public.order_site_selections(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_payouts
    ADD CONSTRAINT fk_payouts_publisher FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_performance
    ADD CONSTRAINT fk_performance_publisher FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.publisher_performance
    ADD CONSTRAINT fk_performance_website FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publisher_offerings"
Command was: ALTER TABLE ONLY public.publisher_pricing_rules
    ADD CONSTRAINT fk_pricing_rules_offering FOREIGN KEY (publisher_offering_id) REFERENCES public.publisher_offerings(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_offerings
    ADD CONSTRAINT fk_publisher_offerings_publisher FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publisher_offerings"
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT fk_relationships_offering FOREIGN KEY (offering_id) REFERENCES public.publisher_offerings(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT fk_relationships_publisher FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT fk_relationships_verified_by FOREIGN KEY (verified_by) REFERENCES public.users(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.publisher_offering_relationships
    ADD CONSTRAINT fk_relationships_website FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "formatting_qa_sessions"
Command was: ALTER TABLE ONLY public.formatting_qa_checks
    ADD CONSTRAINT formatting_qa_checks_qa_session_id_formatting_qa_sessions_id_fk FOREIGN KEY (qa_session_id) REFERENCES public.formatting_qa_sessions(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.formatting_qa_checks
    ADD CONSTRAINT formatting_qa_checks_workflow_id_workflows_id_fk FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.formatting_qa_sessions
    ADD CONSTRAINT formatting_qa_sessions_workflow_id_workflows_id_fk FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "payments"
Command was: ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES public.payments(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.keyword_analysis_batches
    ADD CONSTRAINT keyword_analysis_batches_bulk_analysis_domain_id_fkey FOREIGN KEY (bulk_analysis_domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.keyword_analysis_results
    ADD CONSTRAINT keyword_analysis_results_bulk_analysis_domain_id_fkey FOREIGN KEY (bulk_analysis_domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.keyword_search_history
    ADD CONSTRAINT keyword_search_history_bulk_analysis_domain_id_fkey FOREIGN KEY (bulk_analysis_domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.line_item_changes
    ADD CONSTRAINT line_item_changes_changed_by_fkey FOREIGN KEY (changed_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_line_items"
Command was: ALTER TABLE ONLY public.line_item_changes
    ADD CONSTRAINT line_item_changes_line_item_id_fkey FOREIGN KEY (line_item_id) REFERENCES public.order_line_items(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.line_item_changes
    ADD CONSTRAINT line_item_changes_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT line_item_templates_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.link_orchestration_sessions
    ADD CONSTRAINT link_orchestration_sessions_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "linkio_pages"
Command was: ALTER TABLE ONLY public.linkio_assets
    ADD CONSTRAINT linkio_assets_page_id_fkey FOREIGN KEY (page_id) REFERENCES public.linkio_pages(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "linkio_pages"
Command was: ALTER TABLE ONLY public.linkio_components
    ADD CONSTRAINT linkio_components_page_id_fkey FOREIGN KEY (page_id) REFERENCES public.linkio_pages(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.master_qualification_job_items
    ADD CONSTRAINT master_qualification_job_items_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES public.bulk_analysis_domains(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "master_qualification_jobs"
Command was: ALTER TABLE ONLY public.master_qualification_job_items
    ADD CONSTRAINT master_qualification_job_items_job_id_fkey FOREIGN KEY (job_id) REFERENCES public.master_qualification_jobs(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.master_qualification_jobs
    ADD CONSTRAINT master_qualification_jobs_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_benchmarks
    ADD CONSTRAINT order_benchmarks_captured_by_fkey FOREIGN KEY (captured_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_benchmarks
    ADD CONSTRAINT order_benchmarks_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.order_benchmarks
    ADD CONSTRAINT order_benchmarks_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.order_groups
    ADD CONSTRAINT order_groups_bulk_analysis_project_id_fkey FOREIGN KEY (bulk_analysis_project_id) REFERENCES public.bulk_analysis_projects(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.order_groups
    ADD CONSTRAINT order_groups_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.order_groups
    ADD CONSTRAINT order_groups_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT order_items_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES public.bulk_analysis_domains(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT order_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.guest_post_items
    ADD CONSTRAINT order_items_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_added_by_user_id_fkey FOREIGN KEY (added_by_user_id) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_approved_by_user_id_fkey FOREIGN KEY (approved_by_user_id) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_assigned_domain_id_fkey FOREIGN KEY (assigned_domain_id) REFERENCES public.bulk_analysis_domains(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publisher_offerings"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_publisher_offering_id_fkey FOREIGN KEY (publisher_offering_id) REFERENCES public.publisher_offerings(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "target_pages"
Command was: ALTER TABLE ONLY public.order_line_items
    ADD CONSTRAINT order_line_items_target_page_id_fkey FOREIGN KEY (target_page_id) REFERENCES public.target_pages(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.order_share_tokens
    ADD CONSTRAINT order_share_tokens_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_domains"
Command was: ALTER TABLE ONLY public.order_site_selections
    ADD CONSTRAINT order_site_selections_domain_id_fkey FOREIGN KEY (domain_id) REFERENCES public.bulk_analysis_domains(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "guest_post_items"
Command was: ALTER TABLE ONLY public.order_site_selections
    ADD CONSTRAINT order_site_selections_guest_post_item_id_fkey FOREIGN KEY (order_item_id) REFERENCES public.guest_post_items(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_groups"
Command was: ALTER TABLE ONLY public.order_site_selections
    ADD CONSTRAINT order_site_selections_order_group_id_fkey FOREIGN KEY (order_group_id) REFERENCES public.order_groups(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_site_selections
    ADD CONSTRAINT order_site_selections_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_site_submissions
    ADD CONSTRAINT order_site_submissions_client_reviewed_by_fkey FOREIGN KEY (client_reviewed_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_groups"
Command was: ALTER TABLE ONLY public.order_site_submissions
    ADD CONSTRAINT order_site_submissions_order_group_id_fkey FOREIGN KEY (order_group_id) REFERENCES public.order_groups(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.order_site_submissions
    ADD CONSTRAINT order_site_submissions_submitted_by_fkey FOREIGN KEY (submitted_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "accounts"
Command was: ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.outline_sessions
    ADD CONSTRAINT outline_sessions_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "accounts"
Command was: ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_recorded_by_fkey FOREIGN KEY (recorded_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "polish_sessions"
Command was: ALTER TABLE ONLY public.polish_sections
    ADD CONSTRAINT polish_sections_polish_session_id_fkey FOREIGN KEY (polish_session_id) REFERENCES public.polish_sessions(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.polish_sections
    ADD CONSTRAINT polish_sections_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.polish_sessions
    ADD CONSTRAINT polish_sessions_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_groups"
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_order_group_id_fkey FOREIGN KEY (order_group_id) REFERENCES public.order_groups(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.project_order_associations
    ADD CONSTRAINT project_order_associations_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.bulk_analysis_projects(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.project_websites
    ADD CONSTRAINT project_websites_added_by_fkey FOREIGN KEY (added_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.project_websites
    ADD CONSTRAINT project_websites_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.bulk_analysis_projects(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.project_websites
    ADD CONSTRAINT project_websites_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "email_processing_logs"
Command was: ALTER TABLE ONLY public.publisher_automation_logs
    ADD CONSTRAINT publisher_automation_logs_email_log_id_fkey FOREIGN KEY (email_log_id) REFERENCES public.email_processing_logs(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_automation_logs
    ADD CONSTRAINT publisher_automation_logs_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.publisher_earnings
    ADD CONSTRAINT publisher_earnings_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_line_items"
Command was: ALTER TABLE ONLY public.publisher_earnings
    ADD CONSTRAINT publisher_earnings_order_line_item_id_fkey FOREIGN KEY (order_line_item_id) REFERENCES public.order_line_items(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_earnings
    ADD CONSTRAINT publisher_earnings_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.publisher_earnings
    ADD CONSTRAINT publisher_earnings_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_email_claims
    ADD CONSTRAINT publisher_email_claims_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.publisher_email_claims
    ADD CONSTRAINT publisher_email_claims_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_paid_by_fkey FOREIGN KEY (paid_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_invoices
    ADD CONSTRAINT publisher_invoices_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_order_analytics
    ADD CONSTRAINT publisher_order_analytics_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.publisher_order_analytics
    ADD CONSTRAINT publisher_order_analytics_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "order_line_items"
Command was: ALTER TABLE ONLY public.publisher_order_notifications
    ADD CONSTRAINT publisher_order_notifications_order_line_item_id_fkey FOREIGN KEY (order_line_item_id) REFERENCES public.order_line_items(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_order_notifications
    ADD CONSTRAINT publisher_order_notifications_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_payment_batches
    ADD CONSTRAINT publisher_payment_batches_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_payment_batches
    ADD CONSTRAINT publisher_payment_batches_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_payment_batches
    ADD CONSTRAINT publisher_payment_batches_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_payment_profiles
    ADD CONSTRAINT publisher_payment_profiles_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.publisher_payment_profiles
    ADD CONSTRAINT publisher_payment_profiles_verified_by_fkey FOREIGN KEY (verified_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.publisher_websites
    ADD CONSTRAINT publisher_websites_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_initiated_by_fkey FOREIGN KEY (initiated_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "payments"
Command was: ALTER TABLE ONLY public.refunds
    ADD CONSTRAINT refunds_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES public.payments(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.shadow_publisher_websites
    ADD CONSTRAINT shadow_publisher_websites_publisher_id_fkey FOREIGN KEY (publisher_id) REFERENCES public.publishers(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.shadow_publisher_websites
    ADD CONSTRAINT shadow_publisher_websites_verified_by_fkey FOREIGN KEY (verified_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.shadow_publisher_websites
    ADD CONSTRAINT shadow_publisher_websites_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "accounts"
Command was: ALTER TABLE ONLY public.stripe_customers
    ADD CONSTRAINT stripe_customers_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.stripe_payment_intents
    ADD CONSTRAINT stripe_payment_intents_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "payments"
Command was: ALTER TABLE ONLY public.stripe_payment_intents
    ADD CONSTRAINT stripe_payment_intents_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES public.payments(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "orders"
Command was: ALTER TABLE ONLY public.stripe_webhooks
    ADD CONSTRAINT stripe_webhooks_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "stripe_payment_intents"
Command was: ALTER TABLE ONLY public.stripe_webhooks
    ADD CONSTRAINT stripe_webhooks_payment_intent_id_fkey FOREIGN KEY (payment_intent_id) REFERENCES public.stripe_payment_intents(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.target_pages
    ADD CONSTRAINT target_pages_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.user_client_access
    ADD CONSTRAINT user_client_access_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.user_client_access
    ADD CONSTRAINT user_client_access_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.user_client_access
    ADD CONSTRAINT user_client_access_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.user_website_access
    ADD CONSTRAINT user_website_access_granted_by_fkey FOREIGN KEY (granted_by) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.user_website_access
    ADD CONSTRAINT user_website_access_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.user_website_access
    ADD CONSTRAINT user_website_access_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.website_contacts
    ADD CONSTRAINT website_contacts_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "clients"
Command was: ALTER TABLE ONLY public.website_qualifications
    ADD CONSTRAINT website_qualifications_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.clients(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "bulk_analysis_projects"
Command was: ALTER TABLE ONLY public.website_qualifications
    ADD CONSTRAINT website_qualifications_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.bulk_analysis_projects(id) ON DELETE SET NULL;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.website_qualifications
    ADD CONSTRAINT website_qualifications_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.website_sync_logs
    ADD CONSTRAINT website_sync_logs_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "publishers"
Command was: ALTER TABLE ONLY public.websites
    ADD CONSTRAINT websites_added_by_publisher_id_fkey FOREIGN KEY (added_by_publisher_id) REFERENCES public.publishers(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.websites
    ADD CONSTRAINT websites_added_by_user_id_fkey FOREIGN KEY (added_by_user_id) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.workflow_steps
    ADD CONSTRAINT workflow_steps_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "websites"
Command was: ALTER TABLE ONLY public.workflow_websites
    ADD CONSTRAINT workflow_websites_website_id_fkey FOREIGN KEY (website_id) REFERENCES public.websites(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "workflows"
Command was: ALTER TABLE ONLY public.workflow_websites
    ADD CONSTRAINT workflow_websites_workflow_id_fkey FOREIGN KEY (workflow_id) REFERENCES public.workflows(id) ON DELETE CASCADE;


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_assigned_user_id_fkey FOREIGN KEY (assigned_user_id) REFERENCES public.users(id);


pg_restore: error: could not execute query: ERROR:  there is no unique constraint matching given keys for referenced table "users"
Command was: ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id);


pg_restore: warning: errors ignored on restore: 698
